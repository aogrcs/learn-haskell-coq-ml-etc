#+TITLE:       monads : from concrete to abstract
#+AUTHOR:      Harold Carr
#+DESCRIPTION: monads : from concrete to abstract
#+PROPERTY:    tangle mvanier.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+BEGIN_HTML
---
title: monads : from concrete to abstract
tags: haskell, monads
---
#+END_HTML

# Created       : 2013 Oct 10 (Thu) 16:03:42 by carr.
Last Modified : 2013 Oct 18 (Fri) 22:18:43 by carr.

------------------------------------------------------------------------------
* definition

- [[http://mvanier.livejournal.com/3917.html]]
- [[http://www.haskellforall.com/2013/07/statements-vs-expressions.html]]

Monads:

- Tool for structuring computations.

- Generalization of functions, function application, and function -- TODO functions/application/composition
  composition to extend pure functions with other types of computation.
  Each "extension" corresponds to a particular monad:
  - =Monad Maybe=      : failure to produce a result
  - =Monad (Either e)= : errors
  - =Monad []=         : multiple results (i.e., "list")
  - =Monad IO=         : TODO
  - =State=            : TODO
  - =Monad ((->) r)=
  - ...

- Use the type system to partition side-effecting computations from
  pure functions so they do not interfere with each other.

[[http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/GHC-Base.html]] :

#+BEGIN_EXAMPLE
class  Monad m  where
    -- | Sequentially compose two actions, passing any value produced
    -- by the first as an argument to the second.
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
    -- | Sequentially compose two actions, discarding any value produced
    -- by the first, like sequencing operators (such as the semicolon)
    -- in imperative languages.
    (>>)        :: forall a b. m a -> m b -> m b
        -- Explicit for-alls so that we know what order to
        -- give type arguments when desugaring

    -- | Inject a value into the monadic type.
    return      :: a -> m a
    -- | Fail with a message.  This operation is not part of the
    -- mathematical definition of a monad, but is invoked on pattern-match
    -- failure in a @do@ expression.
    fail        :: String -> m a

    {-# INLINE (>>) #-}
    m >> k      = m >>= \_ -> k
    fail s      = error s
#+END_EXAMPLE

------------------------------------------------------------------------------
* setup

#+BEGIN_SRC haskell
{-# LANGUAGE FlexibleInstances #-}

import Control.Monad.State
import Data.Char
import Data.Either
import System.IO
import Test.HUnit hiding (State) -- for unit testing examples
#+END_SRC

** unit test

#+BEGIN_SRC haskell
t :: (Eq a) => (Show a) => String -> [a] -> a -> [Test]
t testName actuals expected = map (\actual -> TestCase $ assertEqual testName expected actual) actuals
#+END_SRC

------------------------------------------------------------------------------
* =Maybe=

The =Monad= aspects of =Maybe= are a tool for structuring the flow of
computations that may return no results (i.e., =Nothing=), for
example, a hash table.

#+BEGIN_EXAMPLE
:i Maybe
-- data Maybe a = Nothing | Just a
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#Maybe]] :

#+BEGIN_EXAMPLE
instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    (Just _) >>  k      = k
    Nothing  >>  _      = Nothing

    return              = Just
    fail _              = Nothing
#+END_EXAMPLE

#+BEGIN_SRC haskell
maybeExampleNonMonadic i f1 f2 =
    case i of
        Nothing -> Nothing
        Just x  -> case f1 x of
                       Nothing -> Nothing
                       Just y  -> Just $ f2 y

exampleMonadic i f1 f2 =
     i >>= (\x -> f1 x) >>= (\y -> return $ f2 y)

exampleMonadicDo i f1 f2 = do
    x <- i
    y <- f1 x
    return $ f2 y

intToNothing     x = Nothing
intToJust        x = Just x
nonMonadicDouble x = x + x
#+END_SRC

#+BEGIN_SRC haskell
t1 = t "m1"
     [maybeExampleNonMonadic Nothing  intToJust    nonMonadicDouble
     ,exampleMonadic         Nothing  intToJust    nonMonadicDouble
     ,exampleMonadicDo       Nothing  intToJust    nonMonadicDouble
     ]
     Nothing

t2 = t "m2"
     [maybeExampleNonMonadic (Just 3) intToNothing nonMonadicDouble
     ,exampleMonadic         (Just 3) intToNothing nonMonadicDouble
     ,exampleMonadicDo       (Just 3) intToNothing nonMonadicDouble
     ]
     Nothing

t3 = t "m3"
     [maybeExampleNonMonadic (Just 3) intToJust    nonMonadicDouble
     ,exampleMonadic         (Just 3) intToJust    nonMonadicDouble
     ,exampleMonadicDo       (Just 3) intToJust    nonMonadicDouble
     ]
     (Just 6)

t4 = t "m4"
     [exampleMonadic         (Just "a") (\x -> Just x) (\y -> y)
     ]
     (Just "a")
#+END_SRC

** TODO
- =Just 1= value constructor creates a =Maybe Int= =Monad= instance
- =>>== given two arguments
  - =Just 1=
  - =(\x -> ... )=
- =>>== applies =(\x -> ... ) 1=
- =\x= function creates a =Nothing= value
- =>>== given two arguments
  - =Nothing=
  - =(\y -> ... )=
- =>>== ignores =\y= function and returns =Nothing=
- =\x= function "unwinds" with that =Nothing= which "unwinds" as the return value of =example=

To see how this is useful in long compositions of =Maybe=, see Real
World Haskell [[http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html][chapter 10]].  Search for =parseP5= (version without
monadic function composition) and =parseP5_take2= (version with
monadic composition --- but using =>>?= instead of =>>==).

Note: in the above, =Just $ f2 y= could have been used in place of
=return $ f2 y= --- they are the same thing in this context.
However, using =return= makes the function generic, as will be seen in
the following examples (which is why =exampleMonadic= is not named
=maybeExampleMonadic=).

------------------------------------------------------------------------------
* =Either=

The =Monad= aspects of =Either= are a tool for structuring the flow of
computations like =Maybe=, but where additional information is given
instead of =Nothing=.  =Left= corresponds to =Nothing=.  =Right=
corresponds to =Just=.

#+BEGIN_EXAMPLE
:i Either
-- data Either a b = Left a | Right b
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Either.html#Either]]

#+BEGIN_EXAMPLE
instance Monad (Either e) where
    return = Right
    Left  l >>= _ = Left l
    Right r >>= k = k r
#+END_EXAMPLE

#+BEGIN_SRC haskell
eitherExampleNonMonadic i f1 f2 =
    case i of
        Left  l -> Left l
        Right x -> case f1 x of
                       Left  l -> Left l
                       Right y -> return $ f2 y

intToLeft  :: Int -> Either Int Int
intToLeft   x = Left x

intToRight :: Int -> Either Int Int
intToRight  x = Right x
#+END_SRC

#+BEGIN_SRC haskell
t5 = t "e1"
     [eitherExampleNonMonadic (Left (-1)) intToRight nonMonadicDouble
     ,exampleMonadic          (Left (-1)) intToRight nonMonadicDouble
     ,exampleMonadicDo        (Left (-1)) intToRight nonMonadicDouble
     ]
     (Left (-1))

t6 = t "e2"
     [eitherExampleNonMonadic (Right 3)   intToLeft  nonMonadicDouble
     ,exampleMonadic          (Right 3)   intToLeft  nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   intToLeft  nonMonadicDouble
     ]
     (Left 3)

t7 = t "e3"
     [eitherExampleNonMonadic (Right 3)   intToRight nonMonadicDouble
     ,exampleMonadic          (Right 3)   intToRight nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   intToRight nonMonadicDouble
     ]
     (Right 6)
#+END_SRC

** TODO : note generic use of =maybe=*

** TODO
- =Just 1= value constructor creates a =Either Int= =Monad= instance
- =>>== given two arguments
  - =Just 1=
  - =(\x -> ... )=
- =>>== applies =(\x -> ... ) 1=
- =\x= function creates a =Nothing= value
- =>>== given two arguments
  - =Nothing=
  - =(\y -> ... )=
- =>>== ignores =\y= function and returns =Nothing=
- =\x= function "unwinds" with that =Nothing= which "unwinds" as the return value of =example=

------------------------------------------------------------------------------
* =[]=

The =Monad= aspects of =[]= (list) are a tool for structuring the flow
of computations that may return zero or more results, similar to
=Maybe= and =Either= return none or one results.

#+BEGIN_EXAMPLE
:i []
-- data [] a = [] | a : [a]
#+END_EXAMPLE

-- [[http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/GHC-Base.html]]

#+BEGIN_EXAMPLE
instance  Monad []  where
    m >>= k             = foldr ((++) . k) [] m
    m >> k              = foldr ((++) . (\ _ -> k)) [] m
    return x            = [x]
    fail _              = []
#+END_EXAMPLE

#+BEGIN_SRC haskell
listExampleNonMonadic i f1 f2 =
    case i of
        [] -> []
        xs -> case f1 xs of
                  [] -> []
                  ys -> f2 ys
#+END_SRC

** TODO define following functions instead of inline anon

#+BEGIN_SRC haskell
t8 = t "l1"
     [listExampleNonMonadic [ ]     ((\x -> [x])::[Int]->[[Int]])  ((\y -> y)::[[Int]]->[[Int]])
     ,exampleMonadic        [ ]      (\x -> [x])                    (\y -> y)
     ,exampleMonadicDo      [ ]      (\x -> [x])                    (\y -> y)
     ]
     []

t9 = t "l2"
     [listExampleNonMonadic [1,2,3] ((\x -> [ ])::[Int]->[[Int]])  ((\y -> y)::[[Int]]->[[Int]])
     ,exampleMonadic        [1,2,3]  (\x -> [ ])                    (\y -> y)
     ,exampleMonadicDo      [1,2,3]  (\x -> [ ])                    (\y -> y)
     ]
     []

t10 = t "l3"
     [listExampleNonMonadic [1,2,3] (\x ->  x)                      (\y -> y)
     ,exampleMonadic        [1,2,3] (\x -> [x])                     (\y -> y)
     ,exampleMonadicDo      [1,2,3] (\x -> [x])                     (\y -> y)
     ]
     [1,2,3]
#+END_SRC

** TODO example =x= without brackets in =l3= above

See also:
- [[http://en.wikibooks.org/wiki/Haskell/Understanding_monads/List]]

------------------------------------------------------------------------------
* =State=

- [[http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#State]]

#+BEGIN_EXAMPLE
:i State
-- type State s = StateT s Data.Functor.Identity.Identity

:i StateT
-- newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}
-- instance Monad m => Monad (StateT s m)

:i runState
-- runState :: State s a -> s -> (a, s)
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/mtl-2.1.1/docs/src/Control-Monad-State-Class.html#MonadState]]

#+BEGIN_EXAMPLE
class Monad m => MonadState s m | m -> s where
    -- | Return the state from the internals of the monad.
    get :: m s
    get = state (\s -> (s, s))

    -- | Replace the state inside the monad.
    put :: s -> m ()
    put s = state (\_ -> ((), s))

    -- | Embed a simple state action into the monad.
    state :: (s -> (a, s)) -> m a
    state f = do
      s <- get
      let ~(a, s') = f s
      put s'
      return a
#+END_EXAMPLE

#+BEGIN_SRC haskell
stateExampleNonMonadicExplicitState i f1 f2 =
    case f1 i of
        (c1 ,s1) -> case f2 s1 of
                        (c2, s2) -> (c1:c2:[], s2)

shift (s:ss) = (chr (ord s - 71), ss)
upper (s:ss) = ( toUpper s      , ss)

t11 = t "s1"
      [stateExampleNonMonadicExplicitState "hello world" shift upper
      ]
      ("!E","llo world")
#+END_SRC

# --------------------------------------------------

#+BEGIN_SRC haskell
bind' ::         (s -> (a, s))   -- leftFun
        -> (a -> (s -> (b, s)))  -- rightFun
        ->       (s -> (b, s))   -- result
bind' leftFun rightFun startState =
    let (result, endState) = leftFun startState
    in  (rightFun result) endState

return' :: a -> (s -> ( a, s))
return'    a =  \s -> ( a, s)

get'    ::       s -> ( s, s)
get'         =  \s -> ( s, s)

put'    :: s ->  s -> ((), s)
put'       s =  \_ -> ((), s)
#+END_SRC

# -------------------------

#+BEGIN_SRC haskell
stateExample' :: (a -> a -> (a1, a)) -> (a -> a -> (a1, a)) -> a -> ([a1], a)
stateExample' f1 f2 x =
   (get'         `bind'`
    \s0 -> f1 s0 `bind'`
    \r1 -> get'  `bind'`
    \s1 -> f2 s1 `bind'`
    \r2 -> get'  `bind'`
    \s2 -> return' (r1:r2:[]) ) x

shift' :: [Char] -> ([Char] -> (Char, [Char]))
shift' (s:ss) = put' ss `bind'` \_ -> return' $ chr (ord s - 71)

upper' :: [Char] -> ([Char] -> (Char, [Char]))
upper' (s:ss) = put' ss `bind'` \_ -> return' $ toUpper s

t12 = t "s2"
      [stateExample' shift' upper' "hello world"
      ]
      ("!E","llo world")
#+END_SRC

#+BEGIN_SRC haskell
stateExampleMonadic :: (String -> State String Char) -> (String -> State String Char) -> State String [Char]
stateExampleMonadic f1 f2 =
    get          >>=
    \s0 -> f1 s0 >>=
    \r1 -> get   >>=
    \s1 -> f2 s1 >>=
    \r2 -> get   >>=
    \s2 -> return (r1:r2:[])

shiftM :: String -> State String Char
shiftM (s:ss) = put ss >>= \x -> return $ chr (ord s - 71)

upperM :: String -> State String Char
upperM (s:ss) = put ss >>= \x -> return $ toUpper s

t13 = t "s3"
      [runState (stateExampleMonadic shiftM upperM) "hello world"
      ]
      ("!E","llo world")

stateExampleMonadicDo    :: MonadState t m => (t      -> m            a   ) -> (t      -> m            a   ) -> m            [a   ]
-- stateExampleMonadicDo ::                   (String -> State String Char) -> (String -> State String Char) -> State String [Char]
stateExampleMonadicDo f1 f2 = do
    s0 <- get
    r1 <- f1 s0
    s1 <- get
    r2 <- f2 s1
    s2 <- get
    return (r1:r2:[])

t14 = t "s4"
      [runState (stateExampleMonadicDo shiftM upperM) "hello world"
      ]
      ("!E","llo world")
#+END_SRC

diagram:
- http://stackoverflow.com/questions/10230562/confusion-over-the-state-monad-code-on-learn-you-a-haskell

shows >>=
- http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm

expansion of haskell's wikibook state monad page:
- http://xyne.archlinux.ca/notes/haskell/the_state_monad.html

useful:
- http://www.codejury.com/handling-state-with-monads/


SEE:?
- http://www.haskell.org/haskellwiki/State_Monad
- [[http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/]]
- http://stackoverflow.com/questions/5310203/how-to-use-instances-of-monad-and-confusion-about
- [[http://embedntks.com/haskells-state-monad/]]

------------------------------------------------------------------------------
* =IO=

** TODO

#+BEGIN_SRC haskell
filename = "/tmp/BAR.txt"
output = "BAR"

ioExampleMonadic :: IO Bool
ioExampleMonadic =
    openFile filename WriteMode          >>=
    \o     -> hPutStrLn o output         >>=
    \_     -> hClose o                   >>=
    \_     -> openFile filename ReadMode >>=
    \i     -> hGetLine i                 >>=
    \input -> hClose i                   >>=
    \_     -> return (input == output)

ioExampleMonadicDo :: IO Bool
ioExampleMonadicDo = do
    o <- openFile filename WriteMode
    hPutStrLn o output
    hClose o
    i <- openFile filename ReadMode
    input <- hGetLine i
    hClose i
    return (input == output)

instance Show (IO Bool) where
    show x = "IO True"

instance Eq (IO Bool) where
     (==) x y = True  -- whatever value this is set to becomes the result of the test

t15 = t "io1"
      [ioExampleMonadic
      ,ioExampleMonadicDo
      ]
      (return True :: IO Bool)
#+END_SRC

------------------------------------------------------------------------------
* example accuracy

#+BEGIN_SRC haskell
main = do
    runTestTT $ TestList $ t1 ++ t2 ++ t3 ++ t4 ++ t5 ++ t6 ++ t7 ++ t8 ++ t9 ++ t10 ++ t11 ++ t12 ++ t13 ++ t14 ++ t15
#+END_SRC
