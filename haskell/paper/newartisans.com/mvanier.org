#+TITLE:       monads : from concrete to abstract
#+AUTHOR:      Harold Carr
#+DESCRIPTION: monads : from concrete to abstract
#+PROPERTY:    tangle mvanier.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+BEGIN_HTML
---
title: monads : from concrete to abstract
tags: haskell, monads
---
#+END_HTML

# Created       : 2013 Oct 10 (Thu) 16:03:42 by carr.
Last Modified : 2013 Oct 17 (Thu) 09:17:57 by carr.

------------------------------------------------------------------------------
* definition

- [[http://mvanier.livejournal.com/3917.html]]
- [[http://www.haskellforall.com/2013/07/statements-vs-expressions.html]]

Monads:

- Tool for structuring computations.

- Generalization of functions, function application, and function -- TODO functions/application/composition
  composition to extend pure functions with other types of computation.
  Each "extension" corresponds to a particular monad:
  - =Monad Maybe= : failure to produce a result
  - =Monad (Either e)= : errors
  - =Monad []= : multiple results (i.e., "list")
  - =State=
  - =Monad IO=
  - =Monad ((->) r)=
  - ...

- Use the type system to partition side-effecting computations from
  pure functions so they do not interfere with each other.

[[http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/GHC-Base.html]] :

#+BEGIN_EXAMPLE
class  Monad m  where
    -- | Sequentially compose two actions, passing any value produced
    -- by the first as an argument to the second.
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
    -- | Sequentially compose two actions, discarding any value produced
    -- by the first, like sequencing operators (such as the semicolon)
    -- in imperative languages.
    (>>)        :: forall a b. m a -> m b -> m b
        -- Explicit for-alls so that we know what order to
        -- give type arguments when desugaring

    -- | Inject a value into the monadic type.
    return      :: a -> m a
    -- | Fail with a message.  This operation is not part of the
    -- mathematical definition of a monad, but is invoked on pattern-match
    -- failure in a @do@ expression.
    fail        :: String -> m a

    {-# INLINE (>>) #-}
    m >> k      = m >>= \_ -> k
    fail s      = error s
#+END_EXAMPLE

** setup

#+BEGIN_SRC haskell
import Control.Monad.State
import Data.Char
import Data.Either
import System.Random
import Test.HUnit hiding (State) -- for unit testing examples

-- TODO DELETE LATER
import qualified Data.ByteString.Lazy.Char8 as L8
import qualified Data.ByteString.Lazy as L
import Data.Char (isSpace)
import Data.Int
import Data.Word
#+END_SRC

------------------------------------------------------------------------------
* function application

** pure

#+BEGIN_EXAMPLE
:t ($)
-- ($) :: (a -> b) -> a -> b

:t show
-- show :: Show a => a -> String

($) (show) 2
-- "2"

show 2
-- "2"
#+END_EXAMPLE

** monadic

TODO

------------------------------------------------------------------------------
* function composition

** pure

#+BEGIN_EXAMPLE
:t (.)
-- (.) :: (b -> c) -> (a -> b) -> a -> c

:t (* 2.3)
-- (* 2.3) :: Fractional a => a -> a

:t (show) . (* 2.3)
-- (show) . (* 2.3) :: (Fractional b, Show b) => b -> String

(show) . (* 2.3) $ 2
-- "4.6"

show ((* 2.3) 2)
-- "4.6"
#+END_EXAMPLE

** monadic

# --------------------------------------------------
*** =Maybe=

The =Monad= aspects of =Maybe= are a tool for structuring the flow of
computations that may return no results (i.e., =Nothing=), for
example, a hash table.

#+BEGIN_EXAMPLE
:i Maybe
-- data Maybe a = Nothing | Just a
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#Maybe]] :

#+BEGIN_EXAMPLE
instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    (Just _) >>  k      = k
    Nothing  >>  _      = Nothing

    return              = Just
    fail _              = Nothing
#+END_EXAMPLE

#+BEGIN_SRC haskell
maybeExampleNonMonadic i f1 f2 =
    case i of
        Nothing -> Nothing
        Just x  -> case f1 x of
                       Nothing -> Nothing
                       Just y  -> Just $ f2 y

exampleMonadic i f1 f2 =
     i >>= (\x -> f1 x) >>= (\y -> return $ f2 y)

exampleMonadicDo i f1 f2 = do
    x <- i
    y <- f1 x
    return $ f2 y

intToNothing     x = Nothing
intToJust        x = Just x
nonMonadicDouble x = x + x
#+END_SRC

** TODO: TEST

#+BEGIN_SRC haskell
t :: (Eq a) => (Show a) => String -> [a] -> a -> [Test]
t testName actuals expected  = map (\actual -> TestCase $ assertEqual testName expected actual) actuals
#+END_SRC

#+BEGIN_SRC haskell
t1 = t "m1"
     [maybeExampleNonMonadic Nothing  intToJust    nonMonadicDouble
     ,exampleMonadic         Nothing  intToJust    nonMonadicDouble
     ,exampleMonadicDo       Nothing  intToJust    nonMonadicDouble
     ]
     Nothing

t2 = t "m2"
     [maybeExampleNonMonadic (Just 3) intToNothing nonMonadicDouble
     ,exampleMonadic         (Just 3) intToNothing nonMonadicDouble
     ,exampleMonadicDo       (Just 3) intToNothing nonMonadicDouble
     ]
     Nothing

t3 = t "m3"
     [maybeExampleNonMonadic (Just 3) intToJust    nonMonadicDouble
     ,exampleMonadic         (Just 3) intToJust    nonMonadicDouble
     ,exampleMonadicDo       (Just 3) intToJust    nonMonadicDouble
     ]
     (Just 6)

t4 = t "m4"
     [exampleMonadic         (Just "a") (\x -> Just x) (\y -> y)
     ]
     (Just "a")
#+END_SRC

** TODO
- =Just 1= value constructor creates a =Maybe Int= =Monad= instance
- =>>== given two arguments
  - =Just 1=
  - =(\x -> ... )=
- =>>== applies =(\x -> ... ) 1=
- =\x= function creates a =Nothing= value
- =>>== given two arguments
  - =Nothing=
  - =(\y -> ... )=
- =>>== ignores =\y= function and returns =Nothing=
- =\x= function "unwinds" with that =Nothing= which "unwinds" as the return value of =example=

To see how this is useful in long compositions of =Maybe=, see Real
World Haskell [[http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html][chapter 10]].  Search for =parseP5= (version without
monadic function composition) and =parseP5_take2= (version with
monadic composition --- but using =>>?= instead of =>>==).

Note: in the above, =Just $ f2 y= could have been used in place of
=return $ f2 y= --- they are the same thing in this context.
However, using =return= makes the function generic, as will be seen in
the following examples (which is why =exampleMonadic= is not named
=maybeExampleMonadic=).

# --------------------------------------------------
*** =Either=

The =Monad= aspects of =Either= are a tool for structuring the flow of
computations like =Maybe=, but where additional information is given
instead of =Nothing=.  =Left= corresponds to =Nothing=.  =Right=
corresponds to =Just=.

#+BEGIN_EXAMPLE
:i Either
-- data Either a b = Left a | Right b
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Either.html#Either]]

#+BEGIN_EXAMPLE
instance Monad (Either e) where
    return = Right
    Left  l >>= _ = Left l
    Right r >>= k = k r
#+END_EXAMPLE

#+BEGIN_SRC haskell
eitherExampleNonMonadic i f1 f2 =
    case i of
        Left  l -> Left l
        Right x -> case f1 x of
                       Left  l -> Left l
                       Right y -> return $ f2 y

intToLeft  :: Int -> Either Int Int
intToLeft   x = Left x

intToRight :: Int -> Either Int Int
intToRight  x = Right x
#+END_SRC

#+BEGIN_SRC haskell
t5 = t "e1"
     [eitherExampleNonMonadic (Left (-1)) intToRight nonMonadicDouble
     ,exampleMonadic          (Left (-1)) intToRight nonMonadicDouble
     ,exampleMonadicDo        (Left (-1)) intToRight nonMonadicDouble
     ]
     (Left (-1))

t6 = t "e2"
     [eitherExampleNonMonadic (Right 3)   intToLeft  nonMonadicDouble
     ,exampleMonadic          (Right 3)   intToLeft  nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   intToLeft  nonMonadicDouble
     ]
     (Left 3)

t7 = t "e3"
     [eitherExampleNonMonadic (Right 3)   intToRight nonMonadicDouble
     ,exampleMonadic          (Right 3)   intToRight nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   intToRight nonMonadicDouble
     ]
     (Right 6)
#+END_SRC

** TODO : note generic use of =maybe=*

** TODO
- =Just 1= value constructor creates a =Either Int= =Monad= instance
- =>>== given two arguments
  - =Just 1=
  - =(\x -> ... )=
- =>>== applies =(\x -> ... ) 1=
- =\x= function creates a =Nothing= value
- =>>== given two arguments
  - =Nothing=
  - =(\y -> ... )=
- =>>== ignores =\y= function and returns =Nothing=
- =\x= function "unwinds" with that =Nothing= which "unwinds" as the return value of =example=

# --------------------------------------------------
*** =[]=

The =Monad= aspects of =[]= (list) are a tool for structuring the flow
of computations that may return zero or more results, similar to
=Maybe= and =Either= return none or one results.

#+BEGIN_EXAMPLE
:i []
-- data [] a = [] | a : [a]
#+END_EXAMPLE

-- [[http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/GHC-Base.html]]

#+BEGIN_EXAMPLE
instance  Monad []  where
    m >>= k             = foldr ((++) . k) [] m
    m >> k              = foldr ((++) . (\ _ -> k)) [] m
    return x            = [x]
    fail _              = []
#+END_EXAMPLE

#+BEGIN_SRC haskell
listExampleNonMonadic i f1 f2 =
    case i of
        [] -> []
        xs -> case f1 xs of
                  [] -> []
                  ys -> f2 ys
#+END_SRC

** TODO define following functions instead of inline anon

#+BEGIN_SRC haskell
t8 = t "l1"
     [listExampleNonMonadic [ ]     ((\x -> [x])::[Int]->[[Int]])  ((\y -> y)::[[Int]]->[[Int]])
     ,exampleMonadic        [ ]      (\x -> [x])                    (\y -> y)
     ,exampleMonadicDo      [ ]      (\x -> [x])                    (\y -> y)
     ]
     []

t9 = t "l2"
     [listExampleNonMonadic [1,2,3] ((\x -> [ ])::[Int]->[[Int]])  ((\y -> y)::[[Int]]->[[Int]])
     ,exampleMonadic        [1,2,3]  (\x -> [ ])                    (\y -> y)
     ,exampleMonadicDo      [1,2,3]  (\x -> [ ])                    (\y -> y)
     ]
     []

t10 = t "l3"
     [listExampleNonMonadic [1,2,3] (\x ->  x)                      (\y -> y)
     ,exampleMonadic        [1,2,3] (\x -> [x])                     (\y -> y)
     ,exampleMonadicDo      [1,2,3] (\x -> [x])                     (\y -> y)
     ]
     [1,2,3]
#+END_SRC

** TODO example =x= without brackets in =l3= above

See also:
- [[http://en.wikibooks.org/wiki/Haskell/Understanding_monads/List]]

# --------------------------------------------------
*** =State=


- [[http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#State]]

#+BEGIN_EXAMPLE
:i State
-- type State s = StateT s Data.Functor.Identity.Identity

:i runState
-- runState :: State s a -> s -> (a, s)

:i StateT
-- newtype StateT s m a = StateT {runStateT :: s -> m (a, s)}
-- instance Monad m => Monad (StateT s m)
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/mtl-2.1.1/docs/src/Control-Monad-State-Class.html#MonadState]]

#+BEGIN_EXAMPLE
class Monad m => MonadState s m | m -> s where
    -- | Return the state from the internals of the monad.
    get :: m s
    get = state (\s -> (s, s))

    -- | Replace the state inside the monad.
    put :: s -> m ()
    put s = state (\_ -> ((), s))

    -- | Embed a simple state action into the monad.
    state :: (s -> (a, s)) -> m a
    state f = do
      s <- get
      let ~(a, s') = f s
      put s'
      return a
#+END_EXAMPLE

#+BEGIN_SRC haskell
stateExampleNonMonadicNoState i f1 f2 =
    case f1 i of
        (c1 ,s1) -> case f2 s1 of
                        (c2, s2) -> (c2, s2 ++ [c1])

shift (s:ss) = (chr (ord s - 71), ss)
upper (s:ss) = ( toUpper s      , ss)

t11 = t "s1"
      [stateExampleNonMonadicNoState "hello world" shift upper
      ]
      ('L',"lo worldhz")

--------------------------------------------------

bind'' ::         (s -> (a, s))   -- step
         -> (a -> (s -> (b, s)))  -- makeStep
         ->       (s -> (b, s))   -- (makeStep result) newState
bind'' step makeStep oldState =
    let (result, newState) = step oldState
    in  (makeStep result) newState

return'' ::  a -> (s -> ( a, s))
return''     a =  \s -> ( a, s)

get''    ::        s -> ( s, s)
get''          =  \s -> ( s, s)

put''    ::  s ->  s -> ((), s)
put''        s =  \_ -> ((), s)

-------------------------

stateExample' f1 =
    get'' `bind''` \s0 -> f1 s0 `bind''`
                   \s1 -> return'' s1

stateExample'' f1 f2 =
    get'' `bind''` \s0 -> f1 s0 `bind''`
                   \s1 -> get'' `bind''` \s1' -> f2 s1' `bind''`
                   \s2 -> get'' `bind''` \s2' -> return'' (s1:s2:[])

shift'' (s:ss) = put'' ss `bind''` \x -> return'' $ chr (ord s - 71)
upper'' (s:ss) = put'' ss `bind''` \x -> return'' $ toUpper s

-- stateExample'  shift''         "hello world"
-- stateExample'' shift'' upper'' "hello world"

-------------------------

getRandom'' :: Random a => StdGen -> (a, StdGen)
getRandom'' =
    get'' `bind''` \gen -> let (val, gen') = random gen
                           in put'' gen' `bind''` \_ -> return'' val

getRandom :: Random a => State StdGen a
getRandom =
    get >>= \gen -> let (val, gen') = random gen
                    in put gen' >>= \_ -> return val

getRandomDo :: Random a => State StdGen a
getRandomDo = do
    gen <- get
    let (val, gen') = random gen
    put gen'
    return val
#+END_SRC

#+BEGIN_EXAMPLE
sg <- getStdGen
random sg :: (Int,StdGen)

:t sg
-- sg :: StdGen
:t getRandom
-- getRandom :: Random a => State StdGen a
:t runState getRandom
-- runState getRandom :: Random a => StdGen -> (a, StdGen)
:t runState getRandom sg
-- runState getRandom sg :: Random a => (a, StdGen)
getRandom'' sg :: (Int,StdGen)
runState getRandom sg :: (Int,StdGen)
-- (-8057504721392404675,734004948 2103410263)
#+END_EXAMPLE

#+BEGIN_SRC haskell
type Parse a = String -> (a, String)

identity :: a -> Parse a
identity a = (\s -> (a, s))

parse :: Parse a -> String -> a
parse parser initState
    = case parser initState of
        (result, _) -> result
#+END_SRC

#+BEGIN_EXAMPLE
:type parse (identity 1) undefined
parse (identity 1) undefined
parse (identity "foo") undefined
#+END_EXAMPLE

#+BEGIN_SRC haskell
data ParseState' = ParseState' {
      string :: L.ByteString
    , offset :: Int64           -- imported from Data.Int
    } deriving (Show)

newtype Parse' a = Parse' {
      runParse :: ParseState' -> Either String (a, ParseState')
    }

bail :: String -> Parse' a
bail err = Parse' $ \s -> Left $
           "byte offset " ++ show (offset s) ++ ": " ++ err

(==>) :: Parse' a -> (a -> Parse' b) -> Parse' b
firstParser ==> secondParser  =  Parse' chainedParser
  where chainedParser initState   =
          case runParse firstParser initState of
            Left errMessage ->
                Left errMessage
            Right (firstResult, newState) ->
                runParse (secondParser firstResult) newState

getState :: Parse' ParseState'
getState = Parse' (\s -> Right (s, s))

putState :: ParseState' -> Parse' ()
putState s = Parse' (\_ -> Right ((), s))

identity' :: a -> Parse' a
identity' a = Parse' (\s -> Right (a, s))

-- import the Word8 type from Data.Word
parseByte :: Parse' Word8
parseByte =
    getState ==> \initState ->
    case L.uncons (string initState) of
      Nothing ->
          bail "no more input"
      Just (byte,remainder) ->
          putState newState ==> \_ ->
          identity' byte
        where newState = initState { string = remainder,
                                     offset = newOffset }
              newOffset = offset initState + 1
#+END_SRC

#+BEGIN_EXAMPLE
:type parseByte (L8.pack "P5") undefined
parse (identity 1) undefined
parse (identity "foo") undefined
#+END_EXAMPLE

diagram:
http://stackoverflow.com/questions/10230562/confusion-over-the-state-monad-code-on-learn-you-a-haskell

shows >>=
http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm

SEE:?
- [[http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/]]
- http://stackoverflow.com/questions/5310203/how-to-use-instances-of-monad-and-confusion-about
- [[http://embedntks.com/haskells-state-monad/]]

# --------------------------------------------------
*** =IO=


------------------------------------------------------------------------------
* example accuracy

#+BEGIN_SRC haskell
main = do
    runTestTT $ TestList $ t1 ++ t2 ++ t3 ++ t4 ++ t5 ++ t6 ++ t7 ++ t8 ++ t9 ++ t10 ++ t11
#+END_SRC
