#+TITLE:       monads : from concrete to abstract
#+AUTHOR:      Harold Carr
#+DESCRIPTION: monads : from concrete to abstract
#+PROPERTY:    tangle 2013-10-monads-from-concrete-to-abstract.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+BEGIN_HTML
---
title: monads : from concrete to abstract
tags: haskell, monads
---
#+END_HTML

# Created       : 2013 Oct 10 (Thu) 16:03:42 by carr.
Last Modified : 2013 Nov 03 (Sun) 21:56:36 by carr.

------------------------------------------------------------------------------
* definition one : sequencing/piping

A =Monad= is used to pipe the output of one function into another.

A =Monad= causes the first function to be evaluated before the second function (important in a lazy language).

Note: a =Monad= has nothing to do with side-effects.

------------------------------------------------------------------------------
* setup

#+BEGIN_SRC haskell
{-# LANGUAGE FlexibleInstances #-}

import Control.Monad.State
import Data.Char
import Data.Either
import System.IO.Unsafe -- for one unit test
import System.IO
import Test.HUnit hiding (State) -- for unit testing examples
#+END_SRC

** unit test

Rather than showing GHCI input/output this article show test input/expected results.

#+BEGIN_SRC haskell
t :: (Eq a) => (Show a) => String -> [a] -> a -> [Test]
t testName actuals expected = map (TestCase . assertEqual testName expected) actuals
#+END_SRC

------------------------------------------------------------------------------
* =Maybe=

=Maybe= is used for functions that might return no results.

#+BEGIN_EXAMPLE
:i Maybe
-- data Maybe a = Nothing | Just a
#+END_EXAMPLE

For example, a hash table would return =Just <something>= if the key is found, otherwise =Nothing=.

The =Just= and =Nothing= parts of =Maybe= type definition have nothing to do with monads.

A common pattern is to check =Maybe= results:

#+BEGIN_SRC haskell
maybeExampleNonMonadic :: Maybe t -> (t -> Maybe t1) -> (t1 -> a) -> Maybe a
maybeExampleNonMonadic i f1 f2 =
    case i of
        Nothing -> Nothing
        Just x  -> case f1 x of
                       Nothing -> Nothing
                       Just y  -> Just $ f2 y
#+END_SRC

If any result in the pipeline is =Nothing= then stop at that point and
return =Nothing=.  Otherwise, extract the value from =Just= and pass
it to the next function.

In this example, the last function does not return =Maybe= but the
the result of =maybeExampleNonMonadic= is =Maybe=, so the
result of =f2= is "wrapped" with =Just=.

#+BEGIN_SRC haskell
toNothing :: t -> Maybe a
toNothing    x =  Nothing

nonMonadicDouble :: Num a => a -> a
nonMonadicDouble x = x + x

tm1 = t "tm1"
     [maybeExampleNonMonadic Nothing  Just      nonMonadicDouble
     ,maybeExampleNonMonadic (Just 3) toNothing nonMonadicDouble
     ]
     Nothing
#+END_SRC

In =tm1= the result is =Nothing= immediately if the input is
=Nothing=.  Or, if the input is =(Just 3)= but =f1= (here =toNothing=)
returns =Nothing= then =Nothing= is return at that step (and
=nonMonadicDouble= is never called).

#+BEGIN_SRC haskell
tm2 = t "tm2"
     [maybeExampleNonMonadic (Just 3) Just      nonMonadicDouble
     ]
     (Just 6)
#+END_SRC

In =tm2= the result is =(Just 6)= since both the input and =f1= return =Just= results.

Since the pattern in =maybeExampleNonMonadic= is common, it is abstracted into the monadic
aspects of =Maybe= such that it can be rewritten as:

#+BEGIN_SRC haskell
exampleMonadic :: Monad m => m a1 -> (a1 -> m a) -> (a -> b) -> m b
exampleMonadic i f1 f2 =
     i >>= f1 >>= return . f2
#+END_SRC

What remains is the "important" part: piping "successful" computations
from one function to another.  The extraction of values from =Just=,
the short-circuiting of =Nothing= and the sequencing of values is factored
into the =Maybe= =Monad= instance (shown below).

Note: =do= notation can be used instead of =>>== (note: the type
signatures of =exampleMonadic= and =exampleMonadicDo= are identical,
modulo type variable alpha-conversion):

#+BEGIN_SRC haskell
exampleMonadicDo :: Monad m => m t -> (t -> m t1) -> (t1 -> b) -> m b
exampleMonadicDo i f1 f2 = do
    x <- i
    y <- f1 x
    return $ f2 y
#+END_SRC

In the above, =return= can be thought of as an alias (in this context) for =Just= (more on =return= below).

All three version of the example function return equivalent results:

#+BEGIN_SRC haskell
tm3 = t "tm3"
     [maybeExampleNonMonadic Nothing  Just      nonMonadicDouble
     ,exampleMonadic         Nothing  Just      nonMonadicDouble
     ,exampleMonadicDo       Nothing  Just      nonMonadicDouble
     ]
     Nothing

tm4 = t "tm4"
     [maybeExampleNonMonadic (Just 3) toNothing nonMonadicDouble
     ,exampleMonadic         (Just 3) toNothing nonMonadicDouble
     ,exampleMonadicDo       (Just 3) toNothing nonMonadicDouble
     ]
     Nothing

tm5 = t "tm5"
     [maybeExampleNonMonadic (Just 3) Just      nonMonadicDouble
     ,exampleMonadic         (Just 3) Just      nonMonadicDouble
     ,exampleMonadicDo       (Just 3) Just      nonMonadicDouble
     ]
     (Just 6)
#+END_SRC

------------------------------------------------------------------------------
* =>>==

The infix =Monad= =>>== function handles sequencing and extraction:

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#Monad]]

#+BEGIN_EXAMPLE
class  Monad m  where
    -- | Sequentially compose two actions, passing any value produced
    -- by the first as an argument to the second.
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
#+END_EXAMPLE

The short-circuiting of the pipeline on =Nothing= values is done via the =>>== definition
of the =Maybe= =Monad= typeclass instance:

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#Maybe]]

#+BEGIN_EXAMPLE
instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing
#+END_EXAMPLE

=Maybe='s version of =>>== is given a =Maybe= value on the left and a function =k= on the right.

- If the left is =(Just x)= then =x= is extracted and given as the argument to =k=.
  - The return value of =>>== is the return value of =k x=.
- If the left is =Nothing= then the right function is never called.
  - The return value of =>>== is =Nothing=.

------------------------------------------------------------------------------
* =return=

The =Monad= =return= function "wraps" a value with an appropriate =Monad=:

#+BEGIN_EXAMPLE
class  Monad m  where
    -- | Inject a value into the monadic type.
    return      :: a -> m a
#+END_EXAMPLE

In the case of =Maybe=, =return x= is =Just x=:

#+BEGIN_EXAMPLE
instance  Monad Maybe  where
    return              = Just
#+END_EXAMPLE

Type-inferencing in the compiler decides with =instance= or =return= to use.

Note: in =exampleMonadic=, =Just . f2= could have been used in place
of =return . f2= --- they are the same thing in this context.
However, using =return= makes the function generic, as will be seen in
the following examples of other monads (which is why =exampleMonadic=
is not named =maybeExampleMonadic=).

--------------------------------------------------
** example =Maybe= evaluations

Given the definition:

#+BEGIN_EXAMPLE
exampleMonadic :: Monad m => m a1 -> (a1 -> m a) -> (a -> b) -> m b
exampleMonadic i f1 f2 =
     i >>= f1 >>= return . f2
#+END_EXAMPLE

and the application:

#+BEGIN_EXAMPLE
exampleMonadic         Nothing  Just      nonMonadicDouble
#+END_EXAMPLE

- =Nothing= value constructor creates a =Maybe a1= =Monad= instance
- =Nothing= is value of =i=
- =i= is the left argument of the first =>>==
- Since the value is =Nothing=, =f1= is never called and the first =>>== returns =Nothing=
- =Nothing= is the result of =exampleMonadic=

For the application:

#+BEGIN_EXAMPLE
exampleMonadic         (Just 3) toNothing nonMonadicDouble
#+END_EXAMPLE

- =Just 3= value constructor creates a =Maybe Int= =Monad= instance
- =Just 3= is value of =i=
- =i= is the left argument of the first =>>==
- =>>==
  - extracts =3= from =Just=
  - calls =f1 3=
    - =f1=, in this case, is =toNothing=, so the result of =f1 3= is =Nothing=
- =Nothing= is the result of the first =>>-==
- This =Nothing= result is the input to the left side of the second =>>==
- Since the value is =Nothing=, =return . f2= is never called and the second =>>== returns =Nothing=
- =Nothing= is the result of =exampleMonadic=

For the application

#+BEGIN_EXAMPLE
exampleMonadic         (Just 3) Just      nonMonadicDouble
#+END_EXAMPLE

- =Just 3= value constructor creates a =Maybe Int= =Monad= instance
- =Just 3= is value of =i=
- =i= is the left argument of the first =>>==
- first =>>==
  - extracts =3= from =Just=
  - calls =f1 3=
    - =f1=, in this case, is =Just=, so the result of =f1 3= is =Just 3=
- =Just 3= is the result of the first =>>==
- This =Just 3= result is the input to the left side of the second =>>==
- second =>>==
  - extracts =3= from =Just=
  - calls =(return . f2) 3=
    - =f2=, in this case, is =nonMonadicDouble=, so the result of =f2 3= is =6=
    - =6= becomes the input to =return 6=
    - since evaluation is happening in the =Maybe= =Monad= instance, =return 6= results in =Just 6=
- =Just 6= is the result of the second =>>==
- =Just 6= is the result of =exampleMonadic=


To see how monadic chaining is useful in long compositions of =Maybe=, see Real
World Haskell [[http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html][chapter 10]].  Search for =parseP5= (version without
monadic function composition) and =parseP5_take2= (version with
monadic composition --- but using =>>?= instead of =>>==).

------------------------------------------------------------------------------
* =Either=

=Either= is like =Maybe=, but where additional information is given
instead of =Nothing=:

#+BEGIN_EXAMPLE
:i Either
-- data Either a b = Left a | Right b
#+END_EXAMPLE

=Left= corresponds to =Nothing=.  =Right= corresponds to =Just=.

=Either= is typically used such that =(Right x)= signals a successful
evaluation, whereas =(Left x)= signals an error, with =x= containing
information about the error.

The =Left= and =Right= parts of =Either= type definition have nothing to do with monads.

The pattern of using =Either= is identical to =Maybe= except, when
short-circuiting on =Left=, the =Left= information is retained and
returned:

#+BEGIN_SRC haskell
eitherExampleNonMonadic :: Either a t -> (t -> Either a t1) -> (t1 -> b) -> Either a b
eitherExampleNonMonadic i f1 f2 =
    case i of
        Left  l -> Left l
        Right x -> case f1 x of
                       Left  l -> Left l
                       Right y -> return $ f2 y
#+END_SRC

The =Monad= instance of =Either= is also identical to =Maybe= except for retaining =Left= information.

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Either.html#Either]]

#+BEGIN_EXAMPLE
instance  Monad (Either e)  where
    Left  l >>= _ = Left l
    Right r >>= k = k r

    return = Right
#+END_EXAMPLE

The evaluation of =Either= is also identical to =Maybe= exception for retaining/returning =Left= information:

#+BEGIN_SRC haskell
-- These are used instead of Left/Right in the tests
-- so as not to have to repeatedly specify types at point of use.
toRight :: Int -> Either Int Int
toRight = Right

toLeft :: Int -> Either Int Int
toLeft  = Left

te1 = t "te1"
     [eitherExampleNonMonadic (Left (-1)) toRight nonMonadicDouble
     ,exampleMonadic          (Left (-1)) toRight nonMonadicDouble
     ,exampleMonadicDo        (Left (-1)) toRight nonMonadicDouble
     ]
     (Left (-1))

te2 = t "te2"
     [eitherExampleNonMonadic (Right 3)   toLeft  nonMonadicDouble
     ,exampleMonadic          (Right 3)   toLeft  nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   toLeft  nonMonadicDouble
     ]
     (Left 3)

te3 = t "te3"
     [eitherExampleNonMonadic (Right 3)   toRight nonMonadicDouble
     ,exampleMonadic          (Right 3)   toRight nonMonadicDouble
     ,exampleMonadicDo        (Right 3)   toRight nonMonadicDouble
     ]
     (Right 6)
#+END_SRC

Notice how =exampleMonadic= was able to be used with both =Either= and =Maybe=.
That is because the appropriate instance of =>>== and =return= are used based on the type.

** TODO : =Monad= instance definition of =Either= is partically applied type constructor.

------------------------------------------------------------------------------
* =[]=

Just as =Maybe= and =Either= may represent none (=Nothing=, =Left=) or one (=Just=, =Right=) results,
a list:

#+BEGIN_EXAMPLE
:i []
-- data [] a = [] | a : [a]
#+END_EXAMPLE

can be used to represent none (=[]=) or one or more (=[x, ...]=) results.

The list =Monad= typeclass instance:

- [[http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/GHC-Base.html]] (search for =Monad []=)

#+BEGIN_EXAMPLE
instance  Monad []  where
    m >>= k             = foldr ((++) .         k)  [] m

    return x            = [x]
#+END_EXAMPLE

shows that the function =k= is applied to each element of the list
=m=.  Each call to =k= is expected to return zero or more results in a
list.  The results of all the calls to =k= are appended into a single
list.

Therefore the non-monadic version of pipelining function might be:

#+BEGIN_SRC haskell
listExampleNonMonadic :: [a1] -> (a1 -> [a2]) -> (a2 -> a) -> [a]
listExampleNonMonadic i f1 f2 =
    case i of
        [] -> []
        xs -> case concatMap f1 xs of
                  [] -> []
                  ys -> map f2 ys
#+END_SRC


Note: =listExampleNonMonadic= is a bit contrived (as are the examples
in the tests below).  The idea is to keep the examples consistent
between the different =Monad= class instances.

Although the above function checks for =[]= to "short-circuit" further
evaluation, it is not really necessary since any function returning
=[]= will operarate the same:

#+BEGIN_SRC haskell
listExampleNonMonadic' :: [a] -> (a -> [a1]) -> (a1 -> b) -> [b]
listExampleNonMonadic' i f1 f2 =
    let xs = i
        ys = concatMap f1 xs
    in map f2 ys

listExampleNonMonadic'' :: [a1] -> (a1 -> [a]) -> (a -> b) -> [b]
listExampleNonMonadic'' i f1 f2 =
    map f2 $ concatMap f1 i
#+END_SRC


Given the above non-monadic list functions and the existing
=exampleMonadic= functions it can be seen that the list =Monad=
typeclass instance operates like the =Maybe= and =Either= instances:


#+BEGIN_SRC haskell
toEmpty :: Int -> [Int]
toEmpty x = [ ]

toList  :: Int -> [Int]
toList  x = [x]

tl1 = t "tl1"
     [listExampleNonMonadic   [ ]      toList   id
     ,listExampleNonMonadic'  [ ]      toList   id
     ,listExampleNonMonadic'' [ ]      toList   id
     ,exampleMonadic          [ ]      toList   id
     ,exampleMonadicDo        [ ]      toList   id
     ]
     []

tl2 = t "tl2"
     [listExampleNonMonadic   [1,2,3]  toEmpty  id
     ,listExampleNonMonadic'  [1,2,3]  toEmpty  id
     ,listExampleNonMonadic'' [1,2,3]  toEmpty  id
     ,exampleMonadic          [1,2,3]  toEmpty  id
     ,exampleMonadicDo        [1,2,3]  toEmpty  id
     ]
     []

tl3 = t "tl3"
     [listExampleNonMonadic   [1,2,3]  toList   id
     ,listExampleNonMonadic'  [1,2,3]  toList   id
     ,listExampleNonMonadic'' [1,2,3]  toList   id
     ,exampleMonadic          [1,2,3]  toList   id
     ,exampleMonadicDo        [1,2,3]  toList   id
     ]
     [1,2,3]
#+END_SRC

See also:
- [[http://en.wikibooks.org/wiki/Haskell/Understanding_monads/List]]

------------------------------------------------------------------------------
* recap

The monads above did not involve side effects.  They were used for
sequencing and for "wrapping"/"unwrapping" values to/from monads, and,
in the explicit case of =Maybe= and =Either=, to short-circuit further
evaluation on =Nothing= or =Left=.  Explicit short-circuiting was not
necessary in the list =Monad= because there is "nothing to do" on an
empty list.

Notice that the type signatures of all the examples so far are isomorphic:

#+BEGIN_EXAMPLE
maybeExampleNonMonadic  ::             Maybe  t   -> (t  -> Maybe    t1)  -> (t1 -> a) -> Maybe    a
exampleMonadic          ::  Monad m => m     a1   -> (a1 -> m         a)  -> (a  -> b) -> m        b
exampleMonadicDo        ::  Monad m => m      t   -> (t  -> m        t1)  -> (t1 -> b) -> m        b
eitherExampleNonMonadic ::             Either a t -> (t  -> Either a t1)  -> (t1 -> b) -> Either a b
listExampleNonMonadic   ::             [a1]       -> (a1 -> [        a2]) -> (a2 -> a) -> [        a]
#+END_EXAMPLE

and follow the shape of =>>== :

#+BEGIN_EXAMPLE
(>>=)                   :: forall a b. m      a   -> (a  -> m         b)               -> m        b
#+END_EXAMPLE

------------------------------------------------------------------------------
* =IO=

=IO= uses monadic sequencing (=>>==) to ensure that operations happen
in a certain order (e.g., writes happen before reads when prompting
for user input).  Those operations also perform side-effects.  The
side-effects are part of =IO=, not part of =Monad=.

There is no way to write a non-monadic =IO= example as was done for
other =Monad= instances above.  The type system partitions
side-effecting =IO= computation types from pure functions.  Pure
functions guarantee the same results for the same inputs.  =IO= does
not.

#+BEGIN_SRC haskell
ioExampleMonadic   :: FilePath -> String -> IO Bool
ioExampleMonadic filename output =
    openFile filename WriteMode          >>=
    \o     -> hPutStrLn o output         >>=
    \_     -> hClose o                   >>=
    \_     -> openFile filename ReadMode >>=
    \i     -> hGetLine i                 >>=
    \input -> hClose i                   >>=
    \_     -> return (input == output)

ioExampleMonadicDo :: FilePath -> String -> IO Bool
ioExampleMonadicDo filename output = do
    o <- openFile filename WriteMode
    hPutStrLn o output
    hClose o
    i <- openFile filename ReadMode
    input <- hGetLine i
    hClose i
    return (input == output)

ti1 = t "ti1"
      [unsafePerformIO $ ioExampleMonadic   "/tmp/BAR.txt"  "BAR"
      ,unsafePerformIO $ ioExampleMonadicDo "/tmp/BAR.txt"  "BAR"
      ]
      True
#+END_SRC

** TODO - no way to pass a value outside of a monad (except unsafe)

------------------------------------------------------------------------------
* =Monad= laws

- [[http://www.haskell.org/haskellwiki/Monad_laws]]

#+BEGIN_SRC haskell
leftIdentity :: (Eq (m b), Monad m) => a -> (a -> m b) -> Bool
leftIdentity a f = (return a >>= f) == f a

tw1 = t "tw1"
      [leftIdentity  3  ((\x -> Nothing) :: Int -> Maybe Int)
      ,leftIdentity  3   (Just   . (+2))

      ,leftIdentity  3  ((Left   . (+2)) :: Int -> Either Int Int)
      ,leftIdentity  3  ((Right  . (+2)) :: Int -> Either Int Int)

      ,leftIdentity  3   (\x   -> [x*2])
      ,leftIdentity  3  ((\x   -> [   ]) :: Int -> [Int])
      ]
      True

rightIdentity :: (Eq (m b), Monad m) => m b -> Bool
rightIdentity m = (m >>= return) == m

tw2 = t "tw2"
      [rightIdentity   (Just  3)
      ,rightIdentity   (Nothing  :: Maybe Int)

      ,rightIdentity  ((Left  3) :: Either Int Int)
      ,rightIdentity  ((Right 3) :: Either Int Int)

      ,rightIdentity   [3]
      ,rightIdentity  ([]        :: [Int])
      ]
      True

associativity :: (Eq (m b), Monad m) => m a -> (a -> m a1) -> (a1 -> m b) -> Bool
associativity m f g = ((m >>= f) >>= g) == (m >>= (\x -> f x >>= g))

tw3 = t "tw3"
      [associativity (Just 3)  (\x -> Nothing)  (Just . (*2))
      ,associativity (Just 3)  (Just  . (+2))   ((\x -> Nothing) :: Int -> Maybe Int)
      ,associativity (Just 3)  (Just  . (+2))    (Just . (*2))

      ,associativity (Left 3) ((Left  . (+2)) :: Int -> Either Int Int)
                              ((Left  . (*2)) :: Int -> Either Int Int)

      ,associativity (Left 3) ((Right . (+2)) :: Int -> Either Int Int)
                              ((Left  . (*2)) :: Int -> Either Int Int)

      ,associativity [3]       (\x  -> [   ])    (\x -> [x*2])
      ,associativity [3]       (\x  -> [x+2])   ((\x -> [   ])   :: Int -> [Int])
      ,associativity [3]       (\x  -> [x+2])    (\x -> [x*2])
      ]
      True
#+END_SRC

#+results:
: True

------------------------------------------------------------------------------
* =Monad= class

[[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Base.html#Monad]]

#+BEGIN_EXAMPLE
class  Monad m  where
    -- | Sequentially compose two actions, passing any value produced
    -- by the first as an argument to the second.
    (>>=)       :: forall a b. m a -> (a -> m b) -> m b
    -- | Sequentially compose two actions, discarding any value produced
    -- by the first, like sequencing operators (such as the semicolon)
    -- in imperative languages.
    (>>)        :: forall a b. m a -> m b -> m b
        -- Explicit for-alls so that we know what order to
        -- give type arguments when desugaring

    -- | Inject a value into the monadic type.
    return      :: a -> m a
    -- | Fail with a message.  This operation is not part of the
    -- mathematical definition of a monad, but is invoked on pattern-match
    -- failure in a @do@ expression.
    fail        :: String -> m a

    {-# INLINE (>>) #-}
    m >> k      = m >>= \_ -> k
    fail s      = error s
#+END_EXAMPLE

- [[http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Maybe.html#Maybe]] :

#+BEGIN_EXAMPLE
instance  Monad Maybe  where
    (Just x) >>= k      = k x
    Nothing  >>= _      = Nothing

    (Just _) >>  k      = k
    Nothing  >>  _      = Nothing

    return              = Just
    fail _              = Nothing
#+END_EXAMPLE

------------------------------------------------------------------------------
* see also

- [[http://mvanier.livejournal.com/3917.html]]
- [[http://www.haskellforall.com/2013/07/statements-vs-expressions.html]]

------------------------------------------------------------------------------
* example accuracy

#+BEGIN_SRC haskell
main =
    runTestTT $ TestList $ tm1 ++ tm2 ++ tm3 ++ tm4 ++ tm5 ++
                           te1 ++ te2 ++ te3 ++
                           tl1 ++ tl2 ++ tl3 ++
                           ti1 ++
                           tw1 ++ tw2 ++ tw3
#+END_SRC

# End of file.
