-- generated by HCPN NetEdit v0.0
module Unnamed where
import SimpleHCPN
import GuiHCPN
import List (intersperse)

-- declarations

-- markings
data Mark = Mark {
    phil1_ready :: [()]
  , phil1_has_both :: [()]
  , phil1_has_right :: [()]
  , fork2 :: [()]
  , fork1 :: [()]
  , fork3 :: [()]
  , phil3_ready :: [()]
  , phil3_has_both :: [()]
  , phil3_has_right :: [()]
  , phil2_ready :: [()]
  , phil2_has_both :: [()]
  , phil2_has_right :: [()]
  } deriving Show
-- transition actions
phil1_finished :: Mark -> [Mark]
phil1_finished m = 
  do
    let phil1_has_both_marking = phil1_has_both m
    let phil1_ready_marking = phil1_ready m
    let fork1_marking = fork1 m
    let fork2_marking = fork2 m
    ((), phil1_has_both_marking) <- select $ phil1_has_both_marking
    if True
     then return m{ 
              phil1_has_both = phil1_has_both_marking
            , phil1_ready = (()) : phil1_ready_marking
            , fork1 = (()) : fork1_marking
            , fork2 = (()) : fork2_marking
            }
     else fail "guard failed"
phil1_take_left :: Mark -> [Mark]
phil1_take_left m = 
  do
    let fork2_marking = fork2 m
    let phil1_has_right_marking = phil1_has_right m
    let phil1_has_both_marking = phil1_has_both m
    ((), fork2_marking) <- select $ fork2_marking
    ((), phil1_has_right_marking) <- select $ phil1_has_right_marking
    if True
     then return m{ 
              fork2 = fork2_marking
            , phil1_has_right = phil1_has_right_marking
            , phil1_has_both = (()) : phil1_has_both_marking
            }
     else fail "guard failed"
phil1_take_right :: Mark -> [Mark]
phil1_take_right m = 
  do
    let fork1_marking = fork1 m
    let phil1_ready_marking = phil1_ready m
    let phil1_has_right_marking = phil1_has_right m
    ((), fork1_marking) <- select $ fork1_marking
    ((), phil1_ready_marking) <- select $ phil1_ready_marking
    if True
     then return m{ 
              fork1 = fork1_marking
            , phil1_ready = phil1_ready_marking
            , phil1_has_right = (()) : phil1_has_right_marking
            }
     else fail "guard failed"
phil3_finished :: Mark -> [Mark]
phil3_finished m = 
  do
    let phil3_has_both_marking = phil3_has_both m
    let fork3_marking = fork3 m
    let fork1_marking = fork1 m
    let phil3_ready_marking = phil3_ready m
    ((), phil3_has_both_marking) <- select $ phil3_has_both_marking
    if True
     then return m{ 
              phil3_has_both = phil3_has_both_marking
            , fork3 = (()) : fork3_marking
            , fork1 = (()) : fork1_marking
            , phil3_ready = (()) : phil3_ready_marking
            }
     else fail "guard failed"
phil3_takes_left :: Mark -> [Mark]
phil3_takes_left m = 
  do
    let fork1_marking = fork1 m
    let phil3_has_right_marking = phil3_has_right m
    let phil3_has_both_marking = phil3_has_both m
    ((), fork1_marking) <- select $ fork1_marking
    ((), phil3_has_right_marking) <- select $ phil3_has_right_marking
    if True
     then return m{ 
              fork1 = fork1_marking
            , phil3_has_right = phil3_has_right_marking
            , phil3_has_both = (()) : phil3_has_both_marking
            }
     else fail "guard failed"
phil3_takes_right :: Mark -> [Mark]
phil3_takes_right m = 
  do
    let fork3_marking = fork3 m
    let phil3_ready_marking = phil3_ready m
    let phil3_has_right_marking = phil3_has_right m
    ((), fork3_marking) <- select $ fork3_marking
    ((), phil3_ready_marking) <- select $ phil3_ready_marking
    if True
     then return m{ 
              fork3 = fork3_marking
            , phil3_ready = phil3_ready_marking
            , phil3_has_right = (()) : phil3_has_right_marking
            }
     else fail "guard failed"
phil2_finished :: Mark -> [Mark]
phil2_finished m = 
  do
    let phil2_has_both_marking = phil2_has_both m
    let fork2_marking = fork2 m
    let fork3_marking = fork3 m
    let phil2_ready_marking = phil2_ready m
    ((), phil2_has_both_marking) <- select $ phil2_has_both_marking
    if True
     then return m{ 
              phil2_has_both = phil2_has_both_marking
            , fork2 = (()) : fork2_marking
            , fork3 = (()) : fork3_marking
            , phil2_ready = (()) : phil2_ready_marking
            }
     else fail "guard failed"
phil2_takes_left :: Mark -> [Mark]
phil2_takes_left m = 
  do
    let fork3_marking = fork3 m
    let phil2_has_right_marking = phil2_has_right m
    let phil2_has_both_marking = phil2_has_both m
    ((), fork3_marking) <- select $ fork3_marking
    ((), phil2_has_right_marking) <- select $ phil2_has_right_marking
    if True
     then return m{ 
              fork3 = fork3_marking
            , phil2_has_right = phil2_has_right_marking
            , phil2_has_both = (()) : phil2_has_both_marking
            }
     else fail "guard failed"
phil2_takes_right :: Mark -> [Mark]
phil2_takes_right m = 
  do
    let fork2_marking = fork2 m
    let phil2_ready_marking = phil2_ready m
    let phil2_has_right_marking = phil2_has_right m
    ((), fork2_marking) <- select $ fork2_marking
    ((), phil2_ready_marking) <- select $ phil2_ready_marking
    if True
     then return m{ 
              fork2 = fork2_marking
            , phil2_ready = phil2_ready_marking
            , phil2_has_right = (()) : phil2_has_right_marking
            }
     else fail "guard failed"
-- transitions
net = Net{trans=[ Trans{name="phil1_finished",info=Nothing,action=phil1_finished}
                , Trans{name="phil1_take_left",info=Nothing,action=phil1_take_left}
                , Trans{name="phil1_take_right",info=Nothing,action=phil1_take_right}
                , Trans{name="phil3_finished",info=Nothing,action=phil3_finished}
                , Trans{name="phil3_takes_left",info=Nothing,action=phil3_takes_left}
                , Trans{name="phil3_takes_right",info=Nothing,action=phil3_takes_right}
                , Trans{name="phil2_finished",info=Nothing,action=phil2_finished}
                , Trans{name="phil2_takes_left",info=Nothing,action=phil2_takes_left}
                , Trans{name="phil2_takes_right",info=Nothing,action=phil2_takes_right}
                ]} 
-- initial marking
mark = Mark{ phil1_ready = [()]
           , phil1_has_both = []
           , phil1_has_right = []
           , fork2 = [()]
           , fork1 = [()]
           , fork3 = [()]
           , phil3_ready = [()]
           , phil3_has_both = []
           , phil3_has_right = []
           , phil2_ready = [()]
           , phil2_has_both = []
           , phil2_has_right = []
           } 
-- end of net code

main = simMain "philosophers.hcpn" showMarking net mark

showMarking pmap = let (Just nV_phil1_ready) = lookup "phil1_ready" pmap
                       (Just nV_phil1_has_both) = lookup "phil1_has_both" pmap
                       (Just nV_phil1_has_right) = lookup "phil1_has_right" pmap
                       (Just nV_fork2) = lookup "fork2" pmap
                       (Just nV_fork1) = lookup "fork1" pmap
                       (Just nV_fork3) = lookup "fork3" pmap
                       (Just nV_phil3_ready) = lookup "phil3_ready" pmap
                       (Just nV_phil3_has_both) = lookup "phil3_has_both" pmap
                       (Just nV_phil3_has_right) = lookup "phil3_has_right" pmap
                       (Just nV_phil2_ready) = lookup "phil2_ready" pmap
                       (Just nV_phil2_has_both) = lookup "phil2_has_both" pmap
                       (Just nV_phil2_has_right) = lookup "phil2_has_right" pmap
                   in \setPlaceMark m-> do
                         setPlaceMark nV_phil1_ready (concat $ intersperse "," $ map show $ phil1_ready m)
                         setPlaceMark nV_phil1_has_both (concat $ intersperse "," $ map show $ phil1_has_both m)
                         setPlaceMark nV_phil1_has_right (concat $ intersperse "," $ map show $ phil1_has_right m)
                         setPlaceMark nV_fork2 (concat $ intersperse "," $ map show $ fork2 m)
                         setPlaceMark nV_fork1 (concat $ intersperse "," $ map show $ fork1 m)
                         setPlaceMark nV_fork3 (concat $ intersperse "," $ map show $ fork3 m)
                         setPlaceMark nV_phil3_ready (concat $ intersperse "," $ map show $ phil3_ready m)
                         setPlaceMark nV_phil3_has_both (concat $ intersperse "," $ map show $ phil3_has_both m)
                         setPlaceMark nV_phil3_has_right (concat $ intersperse "," $ map show $ phil3_has_right m)
                         setPlaceMark nV_phil2_ready (concat $ intersperse "," $ map show $ phil2_ready m)
                         setPlaceMark nV_phil2_has_both (concat $ intersperse "," $ map show $ phil2_has_both m)
                         setPlaceMark nV_phil2_has_right (concat $ intersperse "," $ map show $ phil2_has_right m)

