-- generated by HCPN NetEdit v0.1
module Unnamed where
import SimpleHCPN
import GuiHCPN
import List (intersperse)

-- declarations
import List((\\))

data Resource = A | B | C deriving (Eq,Show)
type PID = Int
type Process = (PID,[Resource])
type Exclusive = Int
type Shared = Int
type ResourceCount = (Resource,(Exclusive,Shared))

available crs rs = null (crs \\ map fst rs) && all (==0) [ excl | (r,(excl,sh)) <- rs ]
claim_shared crs rs = [ if r `elem` crs then (r,(e,s+1)) else (r,(e,s)) | (r,(e,s)) <- rs ]
release_shared crs rs = [ if r `elem` crs then (r,(e,s-1)) else (r,(e,s)) | (r,(e,s)) <- rs ]

request_exclusive rs = [ (r,(1,s)) | (r,(e,s)) <- rs ]
free_exclusive rs = all (==0) [ s | (r,(e,s)) <- rs ]
release_exclusive rs = [ (r,(0,0)) | (r,_) <- rs ]

-- markings
data Mark = Mark {
    resources :: [[ResourceCount]]
  , non_critical :: [Process]
  , critical :: [Process]
  , locker_ready :: [()]
  , locker_active :: [[ResourceCount]]
  , locker_waiting :: [()]
  } deriving Show
-- transition actions
leave_critical :: Mark -> [Mark]
leave_critical m = 
  do
    let resources_marking = resources m
    let critical_marking = critical m
    let non_critical_marking = non_critical m
    (rs, resources_marking) <- select $ resources_marking
    ((id,crs), critical_marking) <- select $ critical_marking
    if True
     then return m{ 
              resources = (release_shared crs rs) : resources_marking
            , critical = critical_marking
            , non_critical = ((id,crs)) : non_critical_marking
            }
     else fail "guard failed"
enter_critical :: Mark -> [Mark]
enter_critical m = 
  do
    let resources_marking = resources m
    let non_critical_marking = non_critical m
    let critical_marking = critical m
    (rs, resources_marking) <- select $ resources_marking
    ((id,crs), non_critical_marking) <- select $ non_critical_marking
    if available crs rs
     then return m{ 
              resources = (claim_shared crs rs) : resources_marking
            , non_critical = non_critical_marking
            , critical = ((id,crs)) : critical_marking
            }
     else fail "guard failed"
locker_release :: Mark -> [Mark]
locker_release m = 
  do
    let locker_active_marking = locker_active m
    let resources_marking = resources m
    let locker_ready_marking = locker_ready m
    (rs, locker_active_marking) <- select $ locker_active_marking
    if True
     then return m{ 
              locker_active = locker_active_marking
            , resources = (release_exclusive rs) : resources_marking
            , locker_ready = (()) : locker_ready_marking
            }
     else fail "guard failed"
locker_lock :: Mark -> [Mark]
locker_lock m = 
  do
    let resources_marking = resources m
    let locker_waiting_marking = locker_waiting m
    let locker_active_marking = locker_active m
    (rs, resources_marking) <- select $ resources_marking
    ((), locker_waiting_marking) <- select $ locker_waiting_marking
    if free_exclusive rs
     then return m{ 
              resources = resources_marking
            , locker_waiting = locker_waiting_marking
            , locker_active = (rs) : locker_active_marking
            }
     else fail "guard failed"
locker_init :: Mark -> [Mark]
locker_init m = 
  do
    let resources_marking = resources m
    let locker_ready_marking = locker_ready m
    let locker_waiting_marking = locker_waiting m
    (rs, resources_marking) <- select $ resources_marking
    ((), locker_ready_marking) <- select $ locker_ready_marking
    if True
     then return m{ 
              resources = (request_exclusive rs) : resources_marking
            , locker_ready = locker_ready_marking
            , locker_waiting = (()) : locker_waiting_marking
            }
     else fail "guard failed"
-- transitions
net = Net{trans=[ Trans{name="leave_critical",info=Nothing,action=leave_critical}
                , Trans{name="enter_critical",info=Nothing,action=enter_critical}
                , Trans{name="locker_release",info=Nothing,action=locker_release}
                , Trans{name="locker_lock",info=Nothing,action=locker_lock}
                , Trans{name="locker_init",info=Nothing,action=locker_init}
                ]} 
-- initial marking
mark = Mark{ resources = [[(A,(0,0)),(B,(0,0)),(C,(0,0))]]
           , non_critical = [(1,[A]),(2,[B]),(3,[A,B])]
           , critical = []
           , locker_ready = [()]
           , locker_active = []
           , locker_waiting = []
           } 
-- end of net code

main = simMain "locker.hcpn" showMarking net mark

showMarking pmap = let (Just nV_resources) = lookup "resources" pmap
                       (Just nV_non_critical) = lookup "non_critical" pmap
                       (Just nV_critical) = lookup "critical" pmap
                       (Just nV_locker_ready) = lookup "locker_ready" pmap
                       (Just nV_locker_active) = lookup "locker_active" pmap
                       (Just nV_locker_waiting) = lookup "locker_waiting" pmap
                   in \setPlaceMark m-> do
                         setPlaceMark nV_resources (concat $ intersperse "," $ map show $ resources m)
                         setPlaceMark nV_non_critical (concat $ intersperse "," $ map show $ non_critical m)
                         setPlaceMark nV_critical (concat $ intersperse "," $ map show $ critical m)
                         setPlaceMark nV_locker_ready (concat $ intersperse "," $ map show $ locker_ready m)
                         setPlaceMark nV_locker_active (concat $ intersperse "," $ map show $ locker_active m)
                         setPlaceMark nV_locker_waiting (concat $ intersperse "," $ map show $ locker_waiting m)

