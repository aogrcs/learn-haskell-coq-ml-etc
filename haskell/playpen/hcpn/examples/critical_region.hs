-- generated by HCPN NetEdit v0.1
module Unnamed where
import SimpleHCPN
import GuiHCPN
import List (intersperse)

-- declarations

-- markings
data Mark = Mark {
    b_uncritical :: [()]
  , b_waiting :: [()]
  , b_in_critical :: [()]
  , shared_resource :: [()]
  , a_waiting :: [()]
  , a_uncritical :: [()]
  , a_in_critical :: [()]
  } deriving Show
-- transition actions
b_leave_critical :: Mark -> [Mark]
b_leave_critical m = 
  do
    let b_in_critical_marking = b_in_critical m
    let shared_resource_marking = shared_resource m
    let b_uncritical_marking = b_uncritical m
    ((), b_in_critical_marking) <- select $ b_in_critical_marking
    if True
     then return m{ 
              b_in_critical = b_in_critical_marking
            , shared_resource = (()) : shared_resource_marking
            , b_uncritical = (()) : b_uncritical_marking
            }
     else fail "guard failed"
b_needs_resource :: Mark -> [Mark]
b_needs_resource m = 
  do
    let b_uncritical_marking = b_uncritical m
    let b_waiting_marking = b_waiting m
    ((), b_uncritical_marking) <- select $ b_uncritical_marking
    if True
     then return m{ 
              b_uncritical = b_uncritical_marking
            , b_waiting = (()) : b_waiting_marking
            }
     else fail "guard failed"
b_enter_critical :: Mark -> [Mark]
b_enter_critical m = 
  do
    let shared_resource_marking = shared_resource m
    let b_waiting_marking = b_waiting m
    let b_in_critical_marking = b_in_critical m
    ((), shared_resource_marking) <- select $ shared_resource_marking
    ((), b_waiting_marking) <- select $ b_waiting_marking
    if True
     then return m{ 
              shared_resource = shared_resource_marking
            , b_waiting = b_waiting_marking
            , b_in_critical = (()) : b_in_critical_marking
            }
     else fail "guard failed"
a_needs_resource :: Mark -> [Mark]
a_needs_resource m = 
  do
    let a_uncritical_marking = a_uncritical m
    let a_waiting_marking = a_waiting m
    ((), a_uncritical_marking) <- select $ a_uncritical_marking
    if True
     then return m{ 
              a_uncritical = a_uncritical_marking
            , a_waiting = (()) : a_waiting_marking
            }
     else fail "guard failed"
a_leave_critical :: Mark -> [Mark]
a_leave_critical m = 
  do
    let a_in_critical_marking = a_in_critical m
    let shared_resource_marking = shared_resource m
    let a_uncritical_marking = a_uncritical m
    ((), a_in_critical_marking) <- select $ a_in_critical_marking
    if True
     then return m{ 
              a_in_critical = a_in_critical_marking
            , shared_resource = (()) : shared_resource_marking
            , a_uncritical = (()) : a_uncritical_marking
            }
     else fail "guard failed"
a_enter_critical :: Mark -> [Mark]
a_enter_critical m = 
  do
    let shared_resource_marking = shared_resource m
    let a_waiting_marking = a_waiting m
    let a_in_critical_marking = a_in_critical m
    ((), shared_resource_marking) <- select $ shared_resource_marking
    ((), a_waiting_marking) <- select $ a_waiting_marking
    if True
     then return m{ 
              shared_resource = shared_resource_marking
            , a_waiting = a_waiting_marking
            , a_in_critical = (()) : a_in_critical_marking
            }
     else fail "guard failed"
-- transitions
net = Net{trans=[ Trans{name="b_leave_critical",info=Nothing,action=b_leave_critical}
                , Trans{name="b_needs_resource",info=Nothing,action=b_needs_resource}
                , Trans{name="b_enter_critical",info=Nothing,action=b_enter_critical}
                , Trans{name="a_needs_resource",info=Nothing,action=a_needs_resource}
                , Trans{name="a_leave_critical",info=Nothing,action=a_leave_critical}
                , Trans{name="a_enter_critical",info=Nothing,action=a_enter_critical}
                ]} 
-- initial marking
mark = Mark{ b_uncritical = [()]
           , b_waiting = []
           , b_in_critical = []
           , shared_resource = [()]
           , a_waiting = []
           , a_uncritical = [()]
           , a_in_critical = []
           } 
-- end of net code

main = simMain "critical_region.hcpn" showMarking net mark

showMarking pmap = let (Just nV_b_uncritical) = lookup "b_uncritical" pmap
                       (Just nV_b_waiting) = lookup "b_waiting" pmap
                       (Just nV_b_in_critical) = lookup "b_in_critical" pmap
                       (Just nV_shared_resource) = lookup "shared_resource" pmap
                       (Just nV_a_waiting) = lookup "a_waiting" pmap
                       (Just nV_a_uncritical) = lookup "a_uncritical" pmap
                       (Just nV_a_in_critical) = lookup "a_in_critical" pmap
                   in \setPlaceMark m-> do
                         setPlaceMark nV_b_uncritical (concat $ intersperse "," $ map show $ b_uncritical m)
                         setPlaceMark nV_b_waiting (concat $ intersperse "," $ map show $ b_waiting m)
                         setPlaceMark nV_b_in_critical (concat $ intersperse "," $ map show $ b_in_critical m)
                         setPlaceMark nV_shared_resource (concat $ intersperse "," $ map show $ shared_resource m)
                         setPlaceMark nV_a_waiting (concat $ intersperse "," $ map show $ a_waiting m)
                         setPlaceMark nV_a_uncritical (concat $ intersperse "," $ map show $ a_uncritical m)
                         setPlaceMark nV_a_in_critical (concat $ intersperse "," $ map show $ a_in_critical m)

