-- generated by HCPN NetEdit v0.0
module Unnamed where
import SimpleHCPN
import GuiHCPN
import List (intersperse)

-- declarations
infixr :.,:|,:!

data Channel = None
              | Ch Integer deriving (Show,Eq)

data Prefix =  New
              | In Channel 
              | Channel :! Channel 
              deriving Show

data P = Null
       | Prefix :. (Channel->P)
       | P :| P
       deriving Show

rep p = p :| rep p
-- markings
data Mark = Mark {
    free_channels :: [Integer]
  , processes :: [P]
  } deriving Show
-- transition actions
communication :: Mark -> [Mark]
communication m = 
  do
    let processes_marking = processes m
    (In i :. receiver, processes_marking) <- select $ processes_marking
    ((o :! c) :. sender, processes_marking) <- select $ processes_marking
    if i==o
     then return m{ 
              processes = (receiver c) : (sender None) : processes_marking
            }
     else fail "guard failed"
collect :: Mark -> [Mark]
collect m = 
  do
    let processes_marking = processes m
    (Null, processes_marking) <- select $ processes_marking
    if True
     then return m{ 
              processes = processes_marking
            }
     else fail "guard failed"
mix :: Mark -> [Mark]
mix m = 
  do
    let processes_marking = processes m
    (p :| q, processes_marking) <- select $ processes_marking
    if True
     then return m{ 
              processes = (q) : (p) : processes_marking
            }
     else fail "guard failed"
new :: Mark -> [Mark]
new m = 
  do
    let processes_marking = processes m
    let free_channels_marking = free_channels m
    (New :. cont, processes_marking) <- select $ processes_marking
    (c, free_channels_marking) <- select $ free_channels_marking
    if True
     then return m{ 
              processes = (cont (Ch c)) : processes_marking
            , free_channels = (c+1) : free_channels_marking
            }
     else fail "guard failed"
-- transitions
net = Net{trans=[ Trans{name="communication",info=Nothing,action=communication}
                , Trans{name="collect",info=Nothing,action=collect}
                , Trans{name="mix",info=Nothing,action=mix}
                , Trans{name="new",info=Nothing,action=new}
                ]} 
-- initial marking
mark = Mark{ free_channels = [0]
           , processes = [New :. \c-> New :. \d -> ((c :! d) :. \_->Null) :| (In c :. \d-> In d :. \_->Null)]
           } 
-- end of net code

main = simMain "pi.hcpn" showMarking net mark

showMarking pmap = let (Just nV_free_channels) = lookup "free_channels" pmap
                       (Just nV_processes) = lookup "processes" pmap
                   in \setPlaceMark m-> do
                         setPlaceMark nV_free_channels (concat $ intersperse "," $ map show $ free_channels m)
                         setPlaceMark nV_processes (concat $ intersperse "," $ map show $ processes m)

