#+TITLE:       program design by calculation
#+AUTHOR:      Harold Carr
#+DESCRIPTION: program design by calculation
#+PROPERTY:    tangle pdbc.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

#+BEGIN_HTML
---
title: program design by calculation
tags: haskell, monad
---
#+END_HTML

# Created       : 2014 Jul 20 (Sun) 07:59:14 by Harold Carr.
Last Modified : 2014 Jul 22 (Tue) 09:24:12 by Harold Carr.

#+BEGIN_SRC haskell
import Test.HUnit      as T
import Test.HUnit.Util as U -- https://github.com/haroldcarr/test-hunit-util
#+END_SRC

------------------------------------------------------------------------------
* 2.2 function application

TODO

------------------------------------------------------------------------------
* 2.3 function composition

aka "function-arrow chaining"

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#.]]

#+BEGIN_EXAMPLE
(.)    :: (b -> c) -> (a -> b) -> a -> c    -- (2.6)
(.) f g = \x -> f (g x)
#+END_EXAMPLE

[[file:./function-composition.png]]

*associative property*

#+BEGIN_EXAMPLE
(f . g) . h = f . (g . h)   -- (2.8)

-- similar to
(a + b) + c = a + (b + c)
#+END_EXAMPLE

TODO: associative diagram

------------------------------------------------------------------------------
* 2.4 identity function(s)

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#id]]

#+BEGIN_EXAMPLE
id   :: a -> a   -- (2.9)
id x = x
#+END_EXAMPLE

=id= does not lose any information

=id= is the /unit/ of composition

#+BEGIN_EXAMPLE
f . id = id . f = f  -- (2.10)
#+END_EXAMPLE

[[file:./function-composition-id-is-unit.png]]

------------------------------------------------------------------------------
* 2.5 constant function(s)

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#const]]

#+BEGIN_EXAMPLE
const     :: a -> b -> a   -- (2.12)
const x _ =  x
#+END_EXAMPLE

*constant-fusion property*

#+BEGIN_SRC haskell
fusion     :: (b -> c) -> (a -> b) -> a -> c   -- (2.13)
fusion c f = c . f
#+END_SRC

- ignores result of =f=
- input to =f= can be any type
- output of =f= and input to $const_2$ must be same type
  - but, since polymorphic, can be any type
- output of composition not (necessarily) type related to co/domain of =f=

[[file:./constant-fusion.png]]

constant-fusion example

#+BEGIN_SRC haskell
c :: a -> Char
c = const 'c'

c0 = U.t "c0"
     (const 'c' . (+1)       $ 45)
     'c'

c1 = U.t "c1"
     (const 30  . ("foo" ++) $ "bar")
     30
#+END_SRC

*Exercise 2.1*

- output is codomain of =f=
- ignores 2nd arg (can be of any type)

#+BEGIN_SRC haskell
fc  :: (c -> a) -> c -> b -> a
fc  f c = f . const c
#+END_SRC

[[file:./e2-1a.png]]

#+BEGIN_SRC haskell
fc' :: (c -> a) -> c -> b -> a
fc' f c = const (f c)
#+END_SRC

[[file:./e2-1b.png]]

------------------------------------------------------------------------------
* 2.6 monics and epics

Identity and constant functions are limit points with respect to information preservation
- identity preserves all information
- constant loses all information

All other functions lose some information (regarded as unneeded in context).

Functional programming: art of transforming or losing information in a controlled manner to fit context.

Functions lose information when
- give same output for two or more inputs (e.g., constant function)
- only use one value of codomain (e.g., constant function)

[[http://en.wikipedia.org/wiki/Bijection,_injection_and_surjection]]

Injective functions (aka "one-to-one", "monic") do not lose information
- each element of domain maps to unique element of codomain
- (but not all elements of codomain are necessarily mapped to)
- Categorical generalization of injective functions called "monic"
  - [[http://en.wikipedia.org/wiki/Monic_morphism]]

Surjective functions (aka "onto", "epic") do not lose information
- all elements of codomain are mapped to
- Categorical generalization of surjective functions call "epic" (but converse is not true in all categories)
  - [[http://en.wikipedia.org/wiki/Epimorphism]]

*Exercise 2.2*

#+BEGIN_SRC haskell
data Single = Single deriving Show

epicConstantFunction :: b -> Single
epicConstantFunction = const Single
#+END_SRC

------------------------------------------------------------------------------
* 2.7 isos

A /isomorphic/ function (aka /bijective/) is one-to-one (monic) and onto (epic).

[[http://en.wikipedia.org/wiki/Isomorphism]]

Given $f : A \rightarrow B$,
$f$ has /inverse/
$f^{\circ} : B \rightarrow A$,
such that \\
$f \circ f^{\circ} = id_b \wedge f^{\circ} \circ f = id_a$    -- (2.16)

Isomorphisms are important because they convert between "formats"
without losing information, although the data adopts a different
“shape” in each of them.

"A is isomorphic to B" is written: $A \cong B$.

Isomorphic data domains are regarded as "abstractly" the same.

*example*

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Enum]]

#+BEGIN_SRC haskell
data Weekday = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday
             deriving (Enum, Eq, Ord, Show)

data Seven   = One    | Two    | Three   | Four      | Five     | Six    | Seven
             deriving (Enum, Eq, Ord, Show)

transform :: (Enum a, Ord a, Enum b, Ord b) => a -> b
transform = toEnum . fromEnum

i0 = U.t "i0"
     (transform Tuesday)
     Three

i1 = U.t "i1"
     (transform Three)
     Tuesday

transform2 :: (Enum a, Ord a) => Int -> a
transform2 = toEnum . (`rem` 7)

i2 = U.t "i2"
     (transform2 15)
     Two

i3 = U.t "i3"
     (transform2 15)
     Monday
#+END_SRC

Constants, identities, epics, monics and isos are *closed under
composition* (e.g., the composition of two epics is epic).

------------------------------------------------------------------------------
* 2.8 gluing functions which do not compose --- products

Not every two functions can be composed, e.g., $f : C \rightarrow A$
and $g : C \rightarrow B$ (because domain of one is not codomain of other).

But, since $f$ and $g$ share the same domain $C$, their outputs can be paired (aka "split")

[[http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html#%28%2C%29]]

[[https://hackage.haskell.org/package/base-4.4.0.0/docs/src/Data-Tuple.html]]

#+BEGIN_SRC haskell
-- cartesian product of types
pair :: (c -> a) -> (c -> b) -> c -> (a,b)
pair f g c = (f c, g c)

p0 = U.t "p0"
     (pair transform show Sunday)
     (One, "Sunday")

-- cartesian product of elements
p1 = U.t "p1"
     [ (b,c) | b <- [Sunday, Monday, Tuesday], c <- [One, Two]]
     [(Sunday,One),(Sunday,Two),(Monday,One),(Monday,Two),(Tuesday,One),(Tuesday,Two)]
#+END_SRC

=pair= also notated \\
$\langle f,g \rangle : C \rightarrow A \times B$       -- (2.18) \\
$\langle f,g \rangle c = (f c, g c)$

projections (*$\times$-cancellation property*) -- (2.20)

#+BEGIN_SRC haskell
p2 = U.t "p2" (fst (1,2)) 1
p3 = U.t "p3" (snd (1,2)) 2
#+END_SRC

[[file:./pair.png]]

When domains do not coincide use "product of $f$ and $g$"

$f \times g = \langle f \circ fst, g \circ snd \rangle$    -- (2.22)

#+BEGIN_SRC haskell
product0 :: (c -> a) -> (d -> b) -> (c,d) -> (a,b)
product0 f g cd = (,) ((f . fst) cd) ((g . snd) cd)
#+END_SRC

[[file:./product.png]]

Composition and pair relate to each other via
*product-fusion property* (i.e., pair/split is right-distributive with respect to
composition)

$\langle g,h \rangle \circ f = \langle g \circ f, h \circ f \rangle$  -- (2.24)

[[file:./product-fusion.png]]

Left-distributivity does not hold.  But, for $f \circ
\langle g,h \rangle$ when $f = i \times j$

|        |   | $(i \times j) \circ \langle g,h \rangle$                                                           |
| (2.22) | = | $\langle i \circ fst, j \circ snd \rangle \circ \langle g,h \rangle$                               |
| (2.24) | = | $\langle (i \circ fst) \circ \langle g, h \rangle,(j \circ snd) \circ \langle g,h \rangle \rangle$ |
| (2.8)  | = | $\langle i \circ (fst \circ \langle g, h \rangle),j \circ (snd \circ \langle g,h \rangle) \rangle$ |
| (2.20) | = | $\langle i \circ g,j \circ h \rangle$                                                              |

Called *$\times$-absorption property* : pair absorbs $\times$ as a kind of fusion -- a
consequence for $\times$-fusion and $\times$-cancellation.

$(i \times j) \circ \langle g,h \rangle = \langle i \circ g,j \circ h \rangle$  -- (2.25)

[[file:./times-absorption.png]]

#+BEGIN_SRC haskell
-- non-optimized version
pcp                        :: (d -> a) -> (e -> b) -> (c -> d) -> (c -> e) -> c -> (a, b)
pcp                i j g h = (product0 i j) . (pair g h)

-- optimized version
productComposePair         :: (d -> a) -> (e -> b) -> (c -> d) -> (c -> e) -> c -> (a, b)
productComposePair i j g h = pair (i . g) (j . h)

p4 = U.tt "p4"
     [ (pcp                show read (*2) show   4)
     , (productComposePair show read (*2) show   4)
     ]
     ("8",4)
#+END_SRC

$i \circ fst = fst \circ (i \times j)$ -- (2.26) : given $D \times E$ no need to evaluate $j$ \\
$j \circ snd = snd \circ (i \times j)$ -- (2.27)

*$\times$-functor property*

$(g \circ h) \times (i \circ j) = (g \times i) \circ (h \times j)$ -- (2.28)

*$\times$-functor-id property*

$id_A \times id_B = id_{A \times B}$  -- (2.29)

2.28 and 2.29 called /functorial properities/.

*$\times$-reflexion property*

$\langle fst,snd \rangle = id_{A \times B}$  -- (2.30)

[[file:./times-reflexion.png]]

*commutative property* of product

$A \times B \cong B \times A$ -- (2.31)

$\langle snd,fst \rangle = swap$

#+BEGIN_SRC haskell
swap0    :: (a,b) -> (b,a)
swap0 ab = (,) (snd ab) (fst ab)
-- swap0 (a,b) = (b,a)
#+END_SRC

Isomorphic:

|        |   | $swap \circ swap$                                                              |
|        | = | $\langle snd,fst \rangle \circ swap$                                           |
| (2.24) | = | $\langle snd \circ swap,fst \circ swap \rangle$                                |
|        | = | $\langle snd \circ \langle snd,fst \rangle, fst \circ \langle snd,fst \rangle$ |
| (2.20) | = | $\langle fst,snd \rangle$                                                      |
|        | = | $id$                                                                           |

Therefore, no information is lost (or gained) when swapping fields in record datatypes.

*associative property of product*

$A \times (B \times C) \cong (A \times B) \times C$ -- (2.32)


#+BEGIN_SRC haskell
assocl           :: (a, (b,c)) -> ((a,b),c)
assocl (a,(b,c)) = ((a,b),c)

assocr           :: ((a,b),c) -> (a,(b,c))
-- assocr ((a,b),c) = (a,(b,c))
assocr  = pair (fst . fst) (pair (snd . fst) snd)
#+END_SRC

------------------------------------------------------------------------------

#+BEGIN_SRC haskell
main = do
    T.runTestTT $ T.TestList $ c0 ++ c1 ++ i0 ++ i1 ++ i2 ++ i3 ++ p0 ++ p1 ++ p2 ++ p3 ++ p4
#+END_SRC



