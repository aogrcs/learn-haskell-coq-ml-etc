#+TITLE:       program design by calculation
#+AUTHOR:      Harold Carr
#+DESCRIPTION: program design by calculation
#+PROPERTY:    tangle pdbc.hs
#+OPTIONS:     num:nil toc:t
#+OPTIONS:     skip:nil author:nil email:nil creator:nil timestamp:nil
#+INFOJS_OPT:  view:nil toc:t ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js

# https://www.gnu.org/software/emacs/manual/html_node/org/CSS-support.html
#+BEGIN_HTML
<STYLE> <!-- A{text-decoration:none} --> </STYLE>
#+END_HTML

#+BEGIN_HTML
---
title: program design by calculation
tags: haskell, monad
---
#+END_HTML

# Created       : 2014 Jul 20 (Sun) 07:59:14 by Harold Carr.
Last Modified : 2014 Oct 22 (Wed) 22:58:17 by Harold Carr.

#+BEGIN_SRC haskell
module PDBC where

import Test.HUnit      as T
import Test.HUnit.Util as U -- https://github.com/haroldcarr/test-hunit-util
#+END_SRC

------------------------------------------------------------------------------
* 2.2 function application

TODO

------------------------------------------------------------------------------
* 2.3 function composition (2.6) : $\circ = (B \rightarrow C) \rightarrow (A \rightarrow B) \rightarrow A \rightarrow C$

aka "function-arrow chaining"

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#.]]

#+BEGIN_EXAMPLE
(.)    :: (b -> c) -> (a -> b) -> a -> c
(.) f g = \x -> f (g x)
#+END_EXAMPLE

[[file:./function-composition.png]]

** (2.8) associative property of composition : $(f \circ g) \circ h = f \circ (g \circ h)$

Similar to $(a + b) + c = a + (b + c)$

TODO: associative diagram

------------------------------------------------------------------------------
* 2.4 identity function(s) (2.9) : $id \hspace{0.25em} x = x$

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#id]]

#+BEGIN_EXAMPLE
id   :: a -> a
id x = x
#+END_EXAMPLE

=id= does not lose any information

** (2.10) =id= is the /unit/ of composition : $f \circ id = id \circ f = f$

[[file:./function-composition-id-is-unit.png]]

------------------------------------------------------------------------------
* 2.5 constant function(s) (2.12) : $const \hspace{0.25em} x \hspace{0.25em} \_ =  x$

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#const]]

#+BEGIN_EXAMPLE
const     :: a -> b -> a
const x _ =  x
#+END_EXAMPLE

A function that results after apply =const= to =x=

#+BEGIN_SRC haskell
c' :: a -> Char
c'  = const 'c'
#+END_SRC

loses all information (i.e., ignores its argument).

** (2.13) constant-fusion property : $c \circ f = c$

#+BEGIN_SRC haskell
constantFusion  :: (x -> y) -> x -> Char
constantFusion f = c' . f
#+END_SRC

The following diagram shows
- c' as the function (=const_2=) that results from applying =const= (here shown as =const_1=) to =Char=
- =f= applied to =x= resulting in =y=
- =const_2= applied to =y= resulting in =Char=

[[file:./constant-fusion.png]]

Note
- input to =f= can be any type
- result of =f= can be any type
- ignores result of =f=
- output of constant-fusion not (necessarily) type related to co/domain of =f=

constant-fusion example

#+BEGIN_SRC haskell
c :: a -> Char
c = const 'c'

c0 = U.t "c0"
     (c'        . (+1)       $ 45)
     'c'

c1 = U.t "c1"
     (const 30  . ("foo" ++) $ "bar")
     30
#+END_SRC

*Exercise 2.1*

These two functions have the same type:

#+BEGIN_SRC haskell
fc1 :: (c -> a) -> c -> b -> a
fc1 f c = f . const c

fc2 :: (c -> a) -> c -> b -> a
fc2 f c = const (f c)
#+END_SRC

Regarding the functions that result from applying =fc1= and =fc2= to =f= and =c=

- 1st arg: domain and argument to =f=
- 2nd arg: ignored
- output: codomain and result of =f=

From the outside there is no difference.

On the inside

[[file:./e2-1a.png]]

[[file:./e2-1b.png]]

- fc1' first "remembers" the first arg, then ignores =b=, then applies =f= to the remembered value.
- fc2' first applies =f= to the first arg and "remembers" the result, that is returned after ignoring =b=.

------------------------------------------------------------------------------
* 2.6 monics (one-to-one/injective) and epics (onto/surjective)

Identity and constant functions are limit points with respect to information preservation
- identity preserves all information
- constant loses all information

All other functions lose some information (regarded as unneeded in context).

Functional programming: art of transforming or losing information in a controlled manner to fit context.

Functions lose information when
- give same output for two or more inputs (e.g., constant function)
- only use one value of codomain (e.g., constant function)

[[http://en.wikipedia.org/wiki/Bijection,_injection_and_surjection]]

Injective functions (aka "one-to-one", "monic") do not lose information
- each element of domain maps to unique element of codomain
- (but not all elements of codomain are necessarily mapped to)
- Categorical generalization of injective functions called "monic"
  - [[http://en.wikipedia.org/wiki/Monic_morphism]]

Surjective functions (aka "onto", "epic") do not lose information
- all elements of codomain are mapped to
- Categorical generalization of surjective functions call "epic" (but converse is not true in all categories)
  - [[http://en.wikipedia.org/wiki/Epimorphism]]

*Exercise 2.2*

Under what circumstances is a constant function epic?

#+BEGIN_SRC haskell
data Single = Single deriving Show

epicConstantFunction :: b -> Single
epicConstantFunction = const Single
#+END_SRC

------------------------------------------------------------------------------
* 2.7 isomorphisms (2.16) : $f \circ f^{\circ} = id_b \wedge f^{\circ} \circ f = id_a$

A /isomorphic/ function (aka /bijective/) is one-to-one (monic) and onto (epic).

[[http://en.wikipedia.org/wiki/Isomorphism]]

Given $f : A \rightarrow B$,
$f$ has /inverse/
$f^{\circ} : B \rightarrow A$,
such that 2.16 (above) holds.

Isomorphisms are important because they convert between "formats"
without losing information, although the data adopts a different
“shape” in each of them.

"A is isomorphic to B" is written: $A \cong B$.

Isomorphic data domains are regarded as "abstractly" the same.

*example*

[[http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Enum]]

#+BEGIN_SRC haskell
data Weekday = Sunday | Monday | Tuesday | Wednesday | Thursday | Friday | Saturday
             deriving (Enum, Eq, Ord, Show)

data Seven   = One    | Two    | Three   | Four      | Five     | Six    | Seven
             deriving (Enum, Eq, Ord, Show)

transform :: (Enum a, Ord a, Enum b, Ord b) => a -> b
transform = toEnum . fromEnum

i0 = U.t "i0"
     (transform Tuesday)
     Three

i1 = U.t "i1"
     (transform Three)
     Tuesday

transform2 :: (Enum a, Ord a) => Int -> a
transform2 = toEnum . (`rem` 7)

i2 = U.t "i2"
     (transform2 15)
     Two

i3 = U.t "i3"
     (transform2 15)
     Monday
#+END_SRC

Constants, identities, epics, monics and isos are *closed under
composition* (e.g., the composition of two epics is epic).

------------------------------------------------------------------------------
* 2.8 gluing functions which do not compose --- products

** (2.18) pair def : $\langle f,g \rangle c = (f \hspace{0.25em} c, g \hspace{0.25em} c)$

$\langle f,g \rangle : C \rightarrow A \times B$

Not every two functions can be composed, e.g., $f : C \rightarrow A$
and $g : C \rightarrow B$ (because domain of one is not codomain of other).

But, since $f$ and $g$ share the same domain $C$, their outputs can be paired (aka "split")

[[http://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Tuple.html#%28%2C%29]]

[[https://hackage.haskell.org/package/base-4.4.0.0/docs/src/Data-Tuple.html]]

#+BEGIN_SRC haskell
-- cartesian product of types
pair :: (c -> a) -> (c -> b) -> c -> (a,b)
pair f g c = (f c, g c)

p0 = U.t "p0"
     (pair transform show Sunday)
     (One, "Sunday")

-- cartesian product of elements
p1 = U.t "p1"
     [ (b,c) | b <- [Sunday, Monday, Tuesday], c <- [One, Two]]
     [(Sunday,One),(Sunday,Two),(Monday,One),(Monday,Two),(Tuesday,One),(Tuesday,Two)]
#+END_SRC

** (2.20) $\times$-cancellation property : =fst= / =snd= projections

#+BEGIN_SRC haskell
p2 = U.t "p2" (fst (1,2)) 1
p3 = U.t "p3" (snd (1,2)) 2
#+END_SRC

[[file:./pair.png]]

** (2.22) product of two functions def : $f \times g = \langle f \circ fst, g \circ snd \rangle$

Use when domains do not coincide.

#+BEGIN_SRC haskell
product0 :: (c -> a) -> (d -> b) -> (c,d) -> (a,b)
product0 f g cd = (,) ((f . fst) cd) ((g . snd) cd)
#+END_SRC

[[file:./product.png]]

** (2.24) $\times$-fusion property : $\langle g,h \rangle \circ f = \langle g \circ f, h \circ f \rangle$

Pair/split is right-distributive with respect to composition

[[file:./product-fusion.png]]

Left-distributivity does not hold.

** (2.25) $\times$-absorption property : $(i \times j) \circ \langle g,h \rangle = \langle i \circ g,j \circ h \rangle$

pair absorbs $\times$ as a kind of fusion -- a consequence for $\times$-fusion and $\times$-cancellation.

For $f \circ \langle g,h \rangle$ when $f = i \times j$

|        |   | $(i \times j) \circ \langle g,h \rangle$                                                           |
| (2.22) | = | $\langle i \circ fst, j \circ snd \rangle \circ \langle g,h \rangle$                               |
| (2.24) | = | $\langle (i \circ fst) \circ \langle g, h \rangle,(j \circ snd) \circ \langle g,h \rangle \rangle$ |
| (2.8)  | = | $\langle i \circ (fst \circ \langle g, h \rangle),j \circ (snd \circ \langle g,h \rangle) \rangle$ |
| (2.20) | = | $\langle i \circ g,j \circ h \rangle$                                                              |

[[file:./product-absorption.png]]

#+BEGIN_SRC haskell
-- non-optimized version
pcp                        :: (d -> a) -> (e -> b) -> (c -> d) -> (c -> e) -> c -> (a, b)
pcp                i j g h = product0 i j . pair g h

-- optimized version
productComposePair         :: (d -> a) -> (e -> b) -> (c -> d) -> (c -> e) -> c -> (a, b)
productComposePair i j g h = pair (i . g) (j . h)

p4 = U.tt "p4"
     [ pcp                show read (*2) show   4
     , productComposePair show read (*2) show   4
     ]
     ("8",4)
#+END_SRC

** (2.26) : $i \circ fst = fst \circ (i \times j)$
** (2.27) : $j \circ snd = snd \circ (i \times j)$

- (2.26) : given $D \times E$ no need to evaluate $j$
- (2.27) : given $D \times E$ no need to evaluate $i$

** (2.28) $\times$-functor property : $(g \circ h) \times (i \circ j) = (g \times i) \circ (h \times j)$

#+BEGIN_SRC haskell
timesFunctorLeft          :: (e -> a) -> (c -> e) -> (f -> b) -> (d -> f) -> (c, d) -> (a, b)
productFunctorLeft  g h i j = product0 (g . h) (i . j)

productFunctorRight         :: (e -> a) -> (c -> e) -> (f -> b) -> (d -> f) -> (c, d) -> (a, b)
productFunctorRight g h i j = product0 g i . product0 h j
#+END_SRC

** (2.29) $\times$-functor-id property : $id_A \times id_B = id_{A \times B}$

** (2.30) $\times$-reflexion property : $\langle fst,snd \rangle = id_{A \times B}$

[[file:./product-reflexion.png]]

** (2.31) commutative property of product : $A \times B \cong B \times A$

$\langle snd,fst \rangle = swap$

#+BEGIN_SRC haskell
swap0    :: (a,b) -> (b,a)
swap0 ab = (,) (snd ab) (fst ab)
-- swap0 (a,b) = (b,a)
#+END_SRC

Isomorphic:

|        |   | $swap \circ swap$                                                              |
|        | = | $\langle snd,fst \rangle \circ swap$                                           |
| (2.24) | = | $\langle snd \circ swap,fst \circ swap \rangle$                                |
|        | = | $\langle snd \circ \langle snd,fst \rangle, fst \circ \langle snd,fst \rangle$ |
| (2.20) | = | $\langle fst,snd \rangle$                                                      |
|        | = | $id$                                                                           |

Therefore, no information is lost (or gained) when swapping fields in record datatypes.

** (2.32) associative property of product : $A \times (B \times C) \cong (A \times B) \times C$

$assocr = \langle fst \circ fst, \langle snd \circ fst, snd \rangle \rangle$ \\
$assocl = \langle \langle fst, fst \circ snd \rangle, snd \circ snd \rangle$

#+BEGIN_SRC haskell
assocr              :: ((a,b),c) -> (a,(b,c))
-- assocr ((a,b),c) = (a,(b,c))
assocr              = pair   (fst . fst)             (pair (snd . fst) snd)  -- (2.33)

assocl              :: (a, (b,c)) -> ((a,b),c)
-- assocl (a,(b,c)) = ((a,b),c)
assocl              = pair   (pair fst (fst . snd))  (snd . snd)
#+END_SRC

*Exercise 2.3*

|            | $(assocr \circ assocl) (a, (b,c))$                                                                        |
| def        | $(assocr \circ \langle \langle fst, fst \circ snd \rangle, snd \circ snd \rangle) (a, (b, c))$            |
| (2.18)     | $(assocr \circ \langle \langle fst, fst \circ snd \rangle (a, (b, c)), snd \circ snd (a, (b, c))\rangle)$ |
| (2.20) x 2 | $(assocr \circ \langle \langle fst, fst \circ snd \rangle (a, (b, c)), c \rangle)$                        |
| (2.18)     | $(assocr \circ \langle \langle fst (a, (b, c)), fst \circ snd (a, (b, c)) \rangle, c \rangle)$            |
| (2.20) x 3 | $(assocr \circ \langle \langle a, b \rangle, c \rangle)$                                                  |
|            | ...                                                                                                       |
|            | $(a, (b,c))$                                                                                              |

*Exercise 2.4*

|      |   | $((g \circ h) \times (i \circ j))$                             |
| 2.22 | = | $\langle (g \circ h) \circ fst, (i \circ j) \circ snd \rangle$ |
|      |   | ...                                                            |


------------------------------------------------------------------------------
* 2.9 Gluing functions which do not compose — coproducts

** (2.35) either def : $[f,g] : A + B \rightarrow C$

/coproduct/ of $A$ and $B$ is /disjoint union/ data type that has
values "stamped" with different tags to indicate whether the value
came from $A$ or $B$.

[[https://hackage.haskell.org/package/base-4.7.0.0/docs/src/Data-Either.html#either]]

Use =Either= with =Left= / =Right= /injections/.

#+BEGIN_SRC haskell
either :: (a -> c) -> (b -> c) -> Either a b -> c
either f _ (Left  a) = f a
either _ g (Right b) = g b
#+END_SRC

[[file:./either.png]]

/product/ and /coproduct/ are /dual/ mathematical constructs.  Duality
means that everythings said about product $A \times B$ can be rephrased to
coproduct $A + B$.

The sum of two functions =f + g= is the dual of the product of two functions =f × g= :

** (2.37) sum of two functions def : $f + g = [Left \circ f, Right \circ g]$

#+BEGIN_SRC haskell
sum :: (a -> c) -> (b -> d) -> Either a b -> Either c d
sum f _ (Left  a) = Left  $ f a
sum _ g (Right b) = Right $ g b
#+END_SRC

** (2.38) $+$-cancellation property : $[g,h] \circ Left = g$, $[g,h] \circ Right = h$

[[file:./sum-cancellation.png]]

#+BEGIN_SRC haskell
sc1 = U.t "sc1" ((PDBC.either (+10) (*10) . Left)  10)  20
sc2 = U.t "sc2" ((PDBC.either (+10) (*10) . Right) 10) 100
#+END_SRC

** (2.39) $+$-reflexion property : $[ Left, Right ] = id_{A + B}$

[[file:./sum-reflexion.png]]

#+BEGIN_SRC haskell
sr1 = U.t "sr1" (((PDBC.either Left Right)    (Left   10))
                 :: (Show a, Num a, Show b, Num b) => Either a b)
                (id (Left   10))
sr2 = U.t "sr2" (((PDBC.either Left Right)    (Right 100))
                 :: (Show a, Num a, Show b, Num b) => Either a b)
                (id (Right 100))
#+END_SRC

** (2.40) $+$-fusion property : $f \circ [ g , h ] = [ f \circ g , f \circ h ]$

[[file:./sum-fusion.png]]

------------------------------------------------------------------------------

#+BEGIN_SRC haskell
main =
    T.runTestTT $ T.TestList $ c0 ++ c1 ++ i0 ++ i1 ++ i2 ++ i3 ++ p0 ++ p1 ++ p2 ++ p3 ++ p4 ++
                               sc1 ++ sc2 ++ sr1 ++ sr2
#+END_SRC



