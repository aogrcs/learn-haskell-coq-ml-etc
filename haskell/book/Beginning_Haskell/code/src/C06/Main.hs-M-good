{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE LambdaCase            #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell       #-}

module Main where

import           Control.Lens
import           Control.Monad.State
import           Data.Char    (toUpper)
import           Data.Default
import           Data.List
import qualified Data.Map     as M
import           Data.Maybe

class (Default v, Ord v) => Vector v where
    distance :: v   -> v -> Double
    centroid :: [v] -> v

instance Vector (Double, Double) where
    distance (a,b) (c,d) = sqrt $ (c-a)*(c-a) + (d-b)*(d-b)
    centroid lst = let (u,v) = foldr (\(a,b) (c,d) -> (a+c,b+d)) (0.0,0.0) lst
                       n     = fromIntegral $ length lst
                   in (u / n, v / n)

class Vector v => Vectorizable e v where
    toVector :: e -> v

instance Vectorizable (Double,Double) (Double,Double) where
    toVector = id

initializeSimple :: Int -> [e] -> [(Double,Double)]
initializeSimple 0 _ = []
initializeSimple n v = (fromIntegral n, fromIntegral n) : initializeSimple (n-1) v

data KMeansState v = KMeansState { centroids :: [v]
                                 , threshold :: Double
                                 , steps :: Int }

newCentroids :: (Vector v, Vectorizable e v) => M.Map v [e] -> [v]
newCentroids = M.elems . fmap (centroid . map toVector)

clusterAssignments :: (Vector v, Vectorizable e v) => [v] -> [e] -> M.Map v [e]
clusterAssignments centrs points =
    let initialMap = M.fromList $ zip centrs (repeat [])
    in foldr (\p m -> let chosenCentroid = minimumBy (\x y -> compare (distance x $ toVector p)
                                                                      (distance y $ toVector p))
                                                     centrs
                      in M.adjust (p:) chosenCentroid m)
       initialMap points

kMeans' :: (Vector v, Vectorizable e v) => [e] -> State (KMeansState v) [v]
kMeans' points = do
    prevCentrs   <- fmap centroids get
    let assignments = clusterAssignments prevCentrs points
        newCentrs   = newCentroids assignments
    modify (\s -> s { centroids = newCentrs })
    modify (\s -> s { steps = steps s + 1 })
    t <- fmap threshold get
    let err = sum $ zipWith distance prevCentrs newCentrs
    if err < t then return newCentrs else kMeans' points

-- note: version in book left out initialization function
kMeans :: (Vector v, Vectorizable e v) => (Int -> [e] -> [v]) -> Int -> [e] -> Double -> [v]
kMeans i n pts t = evalState (kMeans' pts) (initializeState i n pts t)

-- note: book left this out
initializeState :: (Int -> [e] -> [v]) -> Int -> [e] -> Double -> KMeansState v
initializeState    i                      n      pts    t       = KMeansState (i n pts) t 0

main :: IO ()
main = do
    putStrLn $ show $ kMeans    initializeSimple  2  ([(1,1),(1,2),(4,4),(4,5)]::[(Double,Double)])  0.001

