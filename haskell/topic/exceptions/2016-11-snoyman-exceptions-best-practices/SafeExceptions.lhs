> {-# LANGUAGE NoImplicitPrelude #-}
>
> module SafeExceptions where

https://haskell-lang.org/library/safe-exceptions

Safe and simple exception handling - safe-exceptions library

Safe, consistent, and easy exception handling

lib documentation : http://stackage.org/lts/package/safe-exceptions

runtime exceptions defined in Control.Exception


safe-exceptions functionally equivalent to Control.Exception, but encourages best practices

Goals

functions recognize difference between synchronous and asynchronous exceptions
- synchronous : recoverable : can catch/handle/cleanup
- asynchronous : only cleanup

library prevents following mistakes
- catching/swallowing asynchronous exception
- throwing asynchronous exception  synchronously
- throwing  synchronous exception asynchronously
- swallowing asynchronous exceptions via failing cleanup handlers

Quickstart

DO NOT
import Control.Exception
import Control.Monad.Catch

DO

import  Control.Exception.Safe

Use 'throw' (synonyms 'throwIO', 'throwM')

Catch specific exception with 'catch',    'handle',    'try'
Catch any      exception with 'catchAny', 'handleAny', 'tryAny'

to fork threads and kill them externally : use async : https://www.stackage.org/package/async

avoid (unless you really know what you're doing)
- catchAsync, handleAsync, tryAsync, impureThrow, throwTo

for resource allocation/cleanup use (and don't use the catch/handle/try family
- onException, withException, bracket, bracket_, finally, bracketOnError, bracketOnError_

cookbook : https://github.com/fpco/safe-exceptions/blob/master/COOKBOOK.md


Terminology

definitions based on how exception is thrown (not on what exception is)

SYNCHRONOUS
- generated by current thread
- usually want to recover from them
  - e.g., try file read; file doesn't exist; use default or prompt (instead of exiting program)

ASYNCHRONOUS
- thrown by
  - different user thread
  - by runtime system
- e.g.,
  - async package : race kills longer-running thread with asynchronous exception
  - timeout kill an action
  - deadlock on MVars or STM actions
- usually do not want to recover
  - common mistake

IMPURE EXCEPTIONS HIDDEN INSIDE A PURE VALUE
- exposed by evaluation of that value
  - e.g., 'error', 'undefined', 'impureThrow'
- incomplete pattern matches
- when pure values evaluated and exception exposed, thrown as synchronous exception
- want to recover from impure exceptions

Why catch asynchronous exceptions?

If do not want to to recover from asynchronous exceptions, why catch them?
- reason: resource cleanup (for both sync and async)
- acquire resources (e.g., file descriptors), register cleanup function (guaranteed to run)
  - 'bracket', 'withFile'

Determining sync vs async

GHC runtime : no way to determine if exception thrown sync or async.  Deal via:
- 1
  - make assumptions based on type of exception
- 2
  - run action in separate thread
  - don't give thread ID to anyone else
  - assume that any exception that kills it is a synchronous exception
  - see
    - "catching all exceptions" : https://www.schoolofhaskell.com/user/snoyberg/general-haskell/exceptions/catching-all-exceptions
    - enclosed-exceptions package : https://www.stackage.org/package/enclosed-exceptions
  - BUT
  - expensive to fork thread each time want to deal with exceptions
  - not reliable: leak thread ID; or runtime system to send it an async exception
  - works for actions in IO, trickier for pure functions and monad transformer stacks
    - monad transformer stacks issue is solved via monad-control and exceptions packages
    - pure functions : impossible to provide universal interface for failure for pure andd impure actions

safe exceptions packages use #1 : type info to determine if exception is a/synch
- leverage GHC extensible exception system
  - any exception that is a child of SomeAsyncException is async
  - all others are assumed synch

Handling of sync vs async exceptions

cleanup functions ('bracket', 'finally')
- don't care if a/sync
- call cleanup function
- rethrow exception

catch/recover
- only catch sync
- immediately rethrow async

consider async as stronger/more severe

Exceptions in cleanup code, for possibilities
- action threw  sync, cleanup threw  sync
- action threw  sync, cleanup threw async
- action threw async, cleanup threw  sync
- action threw async, cleanup threw async

PRINCIPLE: do not hide more severe exception with less severe exception

e.g., : action threw sync, cleanup threw async exception
- do not rethrow sync

safe library always throws async if either action or cleanup throws async

Typeclasses

exceptions package (https://www.stackage.org/package/exceptions)
- has abstraction for throwing, catching, cleaning up from exceptions for many different monads
- safe library leverages those type classes to generalize functions

Naming

choices of naming that differ from base libraries:

- throw : for synchronously throwing within a monad (synonyms 'throwIO', 'throwM')
  - as opposed to base where
    - throwIO serves this purpose
    - throw is for impure throwing
      - library provides impureThrow

- catch : does NOT catch async
- use 'catchAsync'
- usually better to use 'bracket', 'withException' : ensure exception is rethrown

Checked vs unchecked

checked : function states explicitly exactly what kinds of exceptions it can throw
- approaches like ExceptT and EitherT are explicit in type of exceptions thrown
- overhead to work with functions return different types of exceptions
  - usually by wrapping all exceptions in sum type
unchecked : can throw some kind of exception
- runtime exceptions : exceptions converted to SomeException via Exception typeclass
  - function signatures do not state which specific exception types can be thrown

library is in the unchecked exception camp

Explicit vs implicit

ExceptT/EitherT advantage
- signature says function may fail
- but, IO actions can throw some kind of exception

attempts at alternative approaches : https://www.stackage.org/package/unexceptionalio

Type-based differentiation

not enforced by the Control.Exception
- throwIO allows  synchronously throwing an asynchronous type
- throwTo allows asynchronously throwing an  synchronous type

safe library prevent that via exception type wrappers
- but if an underlying library does something surprising,
  the functions here may not work correctly

even with safe,

    throw Foo `catch` (\Foo -> ...)

will not trigger exception handler if Foo looks like an asynchronous exception

Deadlock detection exceptions

BlockedIndefinitelyOnMVar / BlockedIndefinitelyOnSTM
- thrown asynchronously by runtime system
- safe treats them as synchronous, because:
  - action taken in local thread
  - By safe standards of recoverable vs non-recoverable
    - in the recoverable category
    - unlike kill signal from another thread
    - want to detect deadlock condition and recover
